
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="代码狗的狗窝">
    <title>malloc源码分析-int_malloc与chunk合并 - 代码狗的狗窝</title>
    <meta name="author" content="fantiq">
    
    
    
    <meta name="description" content="上一篇讲了 ptmalloc 在初始化的过程中做的一些准备工作 主要是内存的申请，这里主要是基于初始化的数据格式对内存进行分配、回收管理。重点是 各种 bin的使用，其如同缓存 减少程序频繁的内存申请操作 对内核的调用(毕竟需要且到内核态执行代码)。">
<meta name="keywords" content="c,内存,malloc,glibc,ptmalloc">
<meta property="og:type" content="blog">
<meta property="og:title" content="malloc源码分析-int_malloc与chunk合并">
<meta property="og:url" content="/2019/05/13/malloc源码分析-int-malloc与chunk合并/index.html">
<meta property="og:site_name" content="代码狗的狗窝">
<meta property="og:description" content="上一篇讲了 ptmalloc 在初始化的过程中做的一些准备工作 主要是内存的申请，这里主要是基于初始化的数据格式对内存进行分配、回收管理。重点是 各种 bin的使用，其如同缓存 减少程序频繁的内存申请操作 对内核的调用(毕竟需要且到内核态执行代码)。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="/2019/05/13/malloc源码分析-int-malloc与chunk合并/WX20190520-120619@2x.png">
<meta property="og:image" content="/2019/05/13/malloc源码分析-int-malloc与chunk合并/WX20190520-205347@2x.png">
<meta property="og:updated_time" content="2019-05-21T06:13:43.876Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="malloc源码分析-int_malloc与chunk合并">
<meta name="twitter:description" content="上一篇讲了 ptmalloc 在初始化的过程中做的一些准备工作 主要是内存的申请，这里主要是基于初始化的数据格式对内存进行分配、回收管理。重点是 各种 bin的使用，其如同缓存 减少程序频繁的内存申请操作 对内核的调用(毕竟需要且到内核态执行代码)。">
<meta name="twitter:image" content="/2019/05/13/malloc源码分析-int-malloc与chunk合并/WX20190520-120619@2x.png">
    
    
        
    
    
        <meta property="og:image" content="/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-ejlztp1tasruqfvoz6xmgqng0anzae8ox7cqjj5yibieqgcmhe9fwxfae6zj.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">代码狗的狗窝</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg"/>
            </a>
            <span class="sidebar-profile-name">fantiq</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分类</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">搜索</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">关于</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="https://github.com/fantiq"
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            malloc源码分析-int_malloc与chunk合并
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" content="Mon May 13 2019 15:16:24 GMT+0800">
	
		    5月 13, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/内存/">内存</a>


    
</div>
</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>上一篇讲了 ptmalloc 在初始化的过程中做的一些准备工作 主要是内存的申请，这里主要是基于初始化的数据格式对内存进行分配、回收管理。重点是 各种 bin的使用，其如同缓存 减少程序频繁的内存申请操作 对内核的调用(毕竟需要且到内核态执行代码)。<br><a id="more"></a></p>
<h2 id="1-0-int-malloc-代码结构"><a href="#1-0-int-malloc-代码结构" class="headerlink" title="1.0 _int_malloc 代码结构"></a>1.0 _int_malloc 代码结构</h2><p>函数 <code>_int_malloc</code> 的代码量很大，代码逻辑主要是基于 bins (fastbin smallbin largebin unsortedbin)查找合适的chunk，这里将函数 <code>_int_malloc</code> 中的代码分成多个部分分析，整个代码结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * _int_malloc (mstate av, <span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">    <span class="comment">// 将用户请求的内存尺寸以 16byte 向上对齐</span></span><br><span class="line">    checked_request2size (bytes, nb);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ())) &#123;</span><br><span class="line">        <span class="comment">//  #1.1 如果用户请求尺寸是在 fast bin 的尺寸范围 则在 fastbin 链表中找合适的chunk 并将地址返回给用户</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">        <span class="comment">//  #1.2 如果用户请求尺寸是在 small bin 的尺寸范围 则在 fastbin 链表中找合适的chunk 并将地址返回给用户</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  #1.3 如果用户请求尺寸是在 large bin 的尺寸范围 则调用函数 malloc_consolidate 对chunk进行处理</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">        <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;</span><br><span class="line">            <span class="comment">// #2.1 在 unsort bin 的链表中查找合适尺寸的chunk 找到的话将内存地址返回给用户</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (nb)) &#123;</span><br><span class="line">            <span class="comment">// #2.2 在large bin 中查找比用户请求尺寸大的 chunk ，找到后讲其切割，用户尺寸部分返回给用户 剩下的内存尺寸给 remainder_chunk</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">            <span class="comment">// #2.3 从整个bin里面查找，这里查找使用了 bitmap 他记录了所有的空闲bin 方便查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        use_top:</span><br><span class="line">            <span class="comment">// #2.4 整个bin里面都没有找到合适的chunk 就要对 top chunk 进行切割，切割下来的返回给用户，剩下的还是 top chunk</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是对用户申请内存尺寸对齐计算的宏 <code>checked_request2size</code> ，这里涉及到多个宏，具体如下：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SIZE_T         size_t <span class="comment">// unsigned long </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ                 (sizeof (INTERNAL_SIZE_T)) <span class="comment">// 在x64 架构上是 8</span></span></span><br><span class="line"><span class="comment">// malloc 对齐尺寸 在 x64 上 这里是 2 * 8 = 16 byte</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT        (2 * SIZE_SZ &lt; __alignof__ (long double) ? __alignof__ (long double) : 2 * SIZE_SZ) </span></span><br><span class="line"><span class="comment">// malloc_chunk 偏移到 属性 fd_nextsize 需要移动的位置是 4 * 8 = 32 byte</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE          (offsetof(struct malloc_chunk, fd_nextsize)) </span></span><br><span class="line"><span class="comment">// 掩码 对齐值减一作为掩码是对齐计算中常用的方法 还要结合取反</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK       (MALLOC_ALIGNMENT - 1) </span></span><br><span class="line"><span class="comment">// 最小尺寸 是需要与 MALLOC_ALIGN_MASK 对齐 也就是 32 byte</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE                 (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)) </span></span><br><span class="line"><span class="comment">// 这里就是将 req 以 16字节向上对齐 req + SIZE_SZ ?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)       (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="comment">// 用户申请的内存最大值不能超过的范围 ? -1 * MINSIZE 能明白 但为什么是 -2 呢</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req) ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">// 处理用户申请的内存尺寸 并判断内存尺寸是否在允许范围内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz) </span></span><br><span class="line">(&#123;</span><br><span class="line">    (sz) = <span class="built_in">request2size</span> (req);</span><br><span class="line">    <span class="keyword">if</span> (((sz) &lt; (req)) || <span class="built_in">REQUEST_OUT_OF_RANGE</span> (sz)) &#123;</span><br><span class="line">        <span class="built_in">__set_errno</span> (ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后是一个判断，如果进程当前通过锁没有抢占到 arena 这里通过函数 <code>sysmalloc</code> 去申请<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">__glibc_unlikely</span> (av == <span class="built_in">NULL</span>)) &#123;</span><br><span class="line">    void *p = <span class="built_in">sysmalloc</span> (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="built_in">NULL</span>) <span class="built_in">alloc_perturb</span> (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-快速直接的查询chunk"><a href="#2-快速直接的查询chunk" class="headerlink" title="2 快速直接的查询chunk"></a>2 快速直接的查询chunk</h2><p>malloc 会尝试先查找合适的chunk 这些chunk会被缓存到各个 bin中，这里先在 fast bin 与 small bin 中进行查询，找到则返回 找不到进入到下一步的处理</p>
<h4 id="2-1-在-fast-bin-上查询合适的chunk"><a href="#2-1-在-fast-bin-上查询合适的chunk" class="headerlink" title="2.1 在 fast bin 上查询合适的chunk"></a>2.1 在 fast bin 上查询合适的chunk</h4><p>代码里使用的宏比较多，这里先展开宏 便于后面代码分析<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="built_in">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = <span class="built_in">catomic_compare_and_exchange_val_acq</span> (fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line"><span class="comment">// idx = sz / 2^4 - 2 = sz / 16 - 2 sz 最小值是 MINSIZE 32 byte 当然 这个值是在 x64 系统上</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)       ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="comment">// 读取arena 对应索引的chunk </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx)    ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似掩码码的作用 00....111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS                   (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"><span class="comment">// 通过掩码将 mchunk_size 底三位设置为 0 ，然后得出 chunk的真实大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)                (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 往后偏移两个 chunk成员属性的位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment">// 往前偏移两个 chunk成员属性的位置 也就是 回到 chunk 内存起始位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure></p>
<p>基于 fast bin 查询 chunk<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果用户请求的尺寸在 fast bin 的缓存范围内，get_max_fast获取的值是 在 malloc_init_state 中设置的</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ())) &#123;</span><br><span class="line">    <span class="comment">// 根据 尺寸计算出 对应在 fastbin 链表中的索引位置 idx</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    <span class="comment">// 读取chunk 这里使用的是地址的地址 方便下面移动fd指针的时候 就将 victim 从链表中移除</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) &#123; <span class="comment">// 条件成功 说明victim不为空 可以返回给用户使用</span></span><br><span class="line">        <span class="comment">// 这里移动fd指针 fd 是地址的地址 也就是移动后会将victim从链表中移除</span></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P) *fb = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span> REMOVE_FB (fb, pp, victim);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 判断下尺寸对应的 fastbin 索引是否相等</span></span><br><span class="line">            <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>)) malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">            <span class="comment">// 调试信息</span></span><br><span class="line">            check_remalloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="comment">// 返回给用户的内存地址是从</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">            <span class="comment">// 调试信息 通过 memset 初始化p内存中值(perturb_byte ^ 0xff)</span></span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-在-small-bin-上查询合适的chunk"><a href="#2-2-在-small-bin-上查询合适的chunk" class="headerlink" title="2.2 在 small bin 上查询合适的chunk"></a>2.2 在 small bin 上查询合适的chunk</h4><p>直接在 small bin 的链表中查找合适的 chunk，常用宏展开<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS          64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH      MALLOC_ALIGNMENT <span class="comment">// 16 byte</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)   </span></span><br><span class="line"><span class="comment">// smallbin 最大值尺寸 64 * 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">// 比较是否用户尺寸小于 smallbin 的最大尺寸</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz) ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"><span class="comment">//根据尺寸计算出对应索引 idx = sz / 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz)  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3)) + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 p 为起始地址 向上偏移 s 长度内存 对其设置 属性 mchunk_size 的 prev_inuse</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s) (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE      0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED      0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA  0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure></p>
<p>small bin 中查找chunk的代码逻辑</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 用户请求的尺寸是否在 smallbin 的尺寸范围内</span><br><span class="line"><span class="symbol">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">    // 通过用户尺寸计算出 small <span class="keyword">bin </span>中对应尺寸的索引 idx</span><br><span class="line">    idx = smallbin_index (nb)<span class="comment">;</span></span><br><span class="line">    // 读取对应的<span class="keyword">bin</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">bin </span>= <span class="keyword">bin_at </span>(av, idx)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> ((victim = last (<span class="keyword">bin)) </span>!= <span class="keyword">bin) </span>&#123; // 不等于他自身说明<span class="keyword">bin </span>不是空的 可以使用</span><br><span class="line">        // 将 查询到的合适的chunk。victim 从 small <span class="keyword">bin </span>的链表中祛除</span><br><span class="line">        <span class="keyword">bck </span>= victim-&gt;<span class="keyword">bk;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">if</span> (__glibc_unlikely (<span class="keyword">bck-&gt;fd </span>!= victim)) malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>)<span class="comment">;</span></span><br><span class="line">        // 设置下一个chunk的 prev_inuse</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">bin-&gt;bk </span>= <span class="keyword">bck;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bck-&gt;fd </span>= <span class="keyword">bin;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       // 若不是主线程 设置size底三位的 NON_MAIN_AREAN</span><br><span class="line">        <span class="meta">if</span> (av != &amp;main_arena) set_non_main_arena (victim)<span class="comment">;</span></span><br><span class="line">        check_malloced_chunk (av, victim, nb)<span class="comment">;</span></span><br><span class="line">        // 转换内存地址为用户地址</span><br><span class="line">        void *p = chunk2mem (victim)<span class="comment">;</span></span><br><span class="line">        alloc_perturb (p, <span class="keyword">bytes);</span></span><br><span class="line"><span class="keyword"> </span>       return p<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-通过-consolidate-合并-空闲chunk"><a href="#2-3-通过-consolidate-合并-空闲chunk" class="headerlink" title="2.3 通过 consolidate 合并 空闲chunk"></a>2.3 通过 consolidate 合并 空闲chunk</h4><p>遍历整个fastbin，各个尺寸对应的链表。先查看上一个chunk 是否未使用，若未使用 将其从链表中移除，也就是与当前chunk合并（后续会通过size的形式实现）<br>然后是下一个chunk，若下一个chunk是top chunk 则是将 当前chunk与top chunk合并，若下一个chunk不是 top chunk，看下一个chunk是否未使用，若未使用则将其与当前chunk合并</p>
<p>整个合并逻辑是在循环中进行的 这样就会将相邻的空闲chunk 合并为一个 最后放入 unsorted bin 或者 top chunk 中提供给后续的内存申请 使用</p>
<p>常用宏：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取chunk的真实尺寸</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">chunksize</span>(p)                    (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span><br><span class="line"><span class="comment">// 将地址从 p 移动到 p+s</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">chunk_at_offset</span>(p, s)           ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="line"><span class="comment">// p指向的chunk的prev_inuse值，上一个chunk是否在使用中</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">prev_inuse</span>(p)                   ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="line"><span class="comment">// p指向的chunk的prev_size</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">prev_size</span>(p)                    ((p)-&gt;mchunk_prev_size)</span><br><span class="line"><span class="comment">// p + s 指向的chunk 将其中的 标志位 prev_inuse 设置为 0</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">clear_inuse_bit_at_offset</span>(p, s) (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="line"><span class="comment">// p + s 指向的chunk 的 prev_inuse 的值</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">inuse_bit_at_offset</span>(p, s) (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure></p>
<p>逻辑代码<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static void malloc_consolidate(mstate av) &#123;</span><br><span class="line">    <span class="comment">// fast bin 结尾</span></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// fast bin 开头</span></span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// p = fb;fb = NULL;</span></span><br><span class="line">        p = atomic_exchange_acq (fb, NULL);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) continue;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                unsigned int idx = fastbin_index (chunksize (p));</span><br><span class="line">                <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb) malloc_printerr (<span class="string">"malloc_consolidate(): invalid chunk size"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            check_inuse_chunk(av, p);</span><br><span class="line">            <span class="comment">// 获取下一个chunk的地址与尺寸</span></span><br><span class="line">            <span class="function"><span class="title">nextp</span> = p-&gt;</span>fd; <span class="comment">// next chunk ptr</span></span><br><span class="line">            size = chunksize (p);</span><br><span class="line">            nextchunk = chunk_at_offset(p, size); <span class="comment">// next chunk ptr</span></span><br><span class="line">            nextsize = chunksize(nextchunk); <span class="comment">// next chunk size</span></span><br><span class="line">            <span class="comment">// 上一个chunk 没有被使用 是空闲的</span></span><br><span class="line">            <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">                <span class="comment">// 移动指针 p 到上一个 chunk 的内存地址</span></span><br><span class="line">                prevsize = prev_size (p);</span><br><span class="line">                size += prevsize;</span><br><span class="line">                p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (<span class="string">"corrupted size vs. prev_size in fastbins"</span>);</span><br><span class="line">                <span class="comment">// 将 p 从链表中取出 这时的p其实是 当前循环到的chunk 的上一个chunk prevchunk</span></span><br><span class="line">                unlink(av, p, bck, fwd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下一个chunk不是top</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (nextchunk != av-&gt;</span>top) &#123;</span><br><span class="line">                <span class="comment">// nextinuse 是nextchunk 是否被使用</span></span><br><span class="line">                nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">                <span class="comment">// 若nextchunk未被使用 则将 nextchunk 从链表中取出</span></span><br><span class="line">                <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">                    size += nextsize;</span><br><span class="line">                    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// nextchunk 不是空闲的 则不合并，将其prev_inuse 设置为 0 </span></span><br><span class="line">                <span class="keyword">else</span> clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将切割下来的 p 加入到 unsorted bin 的列表头部</span></span><br><span class="line">                <span class="function"><span class="title">first_unsorted</span> = unsorted_bin-&gt;</span>fd;</span><br><span class="line">                <span class="function"><span class="title">unsorted_bin</span>-&gt;</span>fd = p;</span><br><span class="line">                <span class="function"><span class="title">first_unsorted</span>-&gt;</span>bk = p;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">                    <span class="function"><span class="title">p</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">                    <span class="function"><span class="title">p</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 prev_inuse 为 1</span></span><br><span class="line">                set_head(p, size | PREV_INUSE);</span><br><span class="line">                <span class="function"><span class="title">p</span>-&gt;</span>bk = unsorted_bin;</span><br><span class="line">                <span class="function"><span class="title">p</span>-&gt;</span>fd = first_unsorted;</span><br><span class="line">                <span class="comment">// 设置 size 这个size 其实是 prevchunk nextchunk 和chunksize 的和 以此实现 将这三个chunk合并的目的 合并后添加到了 unsorted bin 的头部</span></span><br><span class="line">                set_foot(p, size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 如果 p 的下一个 chunk 是 top 将 当前chunk与他的上一个chunk合并到top里</span></span><br><span class="line">                size += nextsize;</span><br><span class="line">                set_head(p, size | PREV_INUSE);</span><br><span class="line">                <span class="function"><span class="title">av</span>-&gt;</span>top = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>); <span class="comment">// 遍历链表</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb); <span class="comment">// 遍历fastbin各个尺寸的chunk链表 移动fb指针 不到结尾则继续计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将chunk从链表中移除的宏：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define unlink(AV, P, BK, FD) </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前的尺寸与下一个chunk中 prev_size 尺寸不相等 </span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>)) malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);</span><br><span class="line">    <span class="comment">// 将 p 从双向链表中移除</span></span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="comment">// 发现 fwd bck p 三者不连续</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) malloc_printerr (<span class="string">"corrupted double-linked list"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="comment">// chunk是large bin 范围的 且 fd_nextsize 不空，说明 p 处在一个尺寸的 chunk 段中的最后一个</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="keyword">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) malloc_printerr (<span class="string">"corrupted double-linked list (not small)"</span>);</span><br><span class="line">            <span class="comment">// large bin 是双向链表 这里需要在 nextsize 的链表中也将其移除</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图是整个合并逻辑的流程图：<br><img src="WX20190520-120619@2x.png" alt="chunk合并流程图"></p>
<h2 id="3-查询chunk-并对当前bin-中的chunk-做处理"><a href="#3-查询chunk-并对当前bin-中的chunk-做处理" class="headerlink" title="3 查询chunk 并对当前bin 中的chunk 做处理"></a>3 查询chunk 并对当前bin 中的chunk 做处理</h2><p>这里是接着上一步 #2 的工作继续进行的，这里不会仅仅对链表上的chunk 做尺寸比较，还会对chunk 做切割、移动的操作。上一步合并chunk到 unsorted bin 、top chunk 的chunk 在这一步里就会用到了。<br>主要逻辑结构如下：</p>
<ol>
<li>在unsorted bin 中查找 chunk</li>
<li>在largebin 中查找大于等于size的chunk进行切割处理</li>
<li>在所有的 bin 中查找大于等于size的chunk进行切割处理</li>
<li>切割 top chunk 返回合适的chunk</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">    int iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="function"><span class="params">((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span> &#123;</span></span><br><span class="line"><span class="function">        // <span class="title">unsorted</span> <span class="title">bin</span> </span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(!in_smallbin_range (nb))</span> &#123;</span></span><br><span class="line"><span class="function">        // <span class="title">large</span> <span class="title">bin</span> </span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ++<span class="title">idx</span>;</span></span><br><span class="line"><span class="function">    <span class="title">bin</span> = <span class="title">bin_at</span> <span class="params">(av, idx)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">block</span> = <span class="title">idx2block</span> <span class="params">(idx)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">map</span> = <span class="title">av</span>-&gt;</span>binmap[block];</span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">        <span class="regexp">// all bins</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    use_top:</span></span><br><span class="line"><span class="regexp">        //</span> cut top chunk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-在-unsorted-bin-上查询合适的chunk"><a href="#3-1-在-unsorted-bin-上查询合适的chunk" class="headerlink" title="3.1 在 unsorted bin 上查询合适的chunk"></a>3.1 在 unsorted bin 上查询合适的chunk</h4><p>循环 unsorted bin ，若unsorted bin的链表中只有一个 chunk 且这个chunk还是last_remainder 尺寸还合适 （size &gt; nb + MINSIZE 这个条件的目的是方便切割 last_remainder）<br>满足条件会将 这个chunk 进行切割 一部分分会给用户 另一部分作为last_remainder </p>
<p>然后就看下 unsorted bin 上面是否有正好满足尺寸的chunk 返回给用户 且要将这个chunk从链表中 移除</p>
<p>在然后就是将这些 chunk 根据尺寸合并到对应的 small bin 或 large bin 对应链表的头部，代码逻辑如下：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历 unsorted bin 链表 ，unsorted bin 的循环是从链表底部开始的 </span></span><br><span class="line"><span class="comment">// victim 会在下面代码中从列表中分割出去，以使这里的循环能够继续下去</span></span><br><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;</span><br><span class="line">    <span class="comment">// victim上一个chunk地址</span></span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    <span class="comment">// victim 下一个chunk地址</span></span><br><span class="line">    mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)|| __glibc_unlikely (size &gt; av-&gt;system_mem)) malloc_printerr (<span class="string">"malloc(): invalid size (unsorted)"</span>);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ) || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem)) malloc_printerr (<span class="string">"malloc(): invalid next size (unsorted)"</span>);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) malloc_printerr (<span class="string">"malloc(): mismatching next-&gt;prev_size (unsorted)"</span>);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) malloc_printerr (<span class="string">"malloc(): unsorted double linked list corrupted"</span>);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next))) malloc_printerr (<span class="string">"malloc(): invalid next-&gt;prev_inuse (unsorted)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尺寸在small bin的范围 且 victim是unsorted bin 链表中的第一个chunk 且 victim 是 last_remainder 且 victim的尺寸大于用户请求的尺寸 + chunk的最小尺寸（目的是方便切割victim）</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned <span class="keyword">long</span>) (size) &gt; (unsigned <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        <span class="comment">// 这里将 victim 分成两份 一份是用户请求的chunk 剩下一份是 remainder</span></span><br><span class="line">        remainder_size = size - nb; <span class="comment">// 剩下部分尺寸</span></span><br><span class="line">        remainder = chunk_at_offset (victim, nb); <span class="comment">// 剩下部分内存地址</span></span><br><span class="line">        <span class="comment">// 由于victim是 unsorted bin 链表中唯一一个chunk 这里将 unsorted bin 这个双向链表的 bk fd 全指向 remainder </span></span><br><span class="line">        <span class="comment">// 其实 这个操作也同时将victim 返回给用户的哪部分内存从链表中移除了</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; </span><br><span class="line">        av-&gt;last_remainder = remainder; <span class="comment">// 剩余部分赋值给 arena 的 last_remainder</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123; <span class="comment">// 如果剩余部分尺寸属于largin bin 需要将其内存中fd_nextsize bk_nextsize位置的数据清空</span></span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="keyword">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 chunk 数据</span></span><br><span class="line">        set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="comment">// 将分割下来的用户部分返回给用户</span></span><br><span class="line">        void *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将victim从 unsorted bin 的链表中移除</span></span><br><span class="line">    <span class="comment">// unsorted bin 这个链表是 栈结构 先进后出的</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="comment">// 尺寸正合适 则可以直接返回给用户了</span></span><br><span class="line">    <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena (victim);</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        void *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下 将每次循环到的victim 重新分配到 small bin 或 large bin中 </span></span><br><span class="line">    <span class="comment">// 这里逻辑先计算一些指针 方便下面合并操作</span></span><br><span class="line">    <span class="comment">// victim的尺寸在 small bin的范围内</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (size)) &#123;</span><br><span class="line">        victim_index = smallbin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// victim的尺寸在 large bin的范围内</span></span><br><span class="line">    <span class="comment">// 这里主要是需要先处理large bin 中的 nextsize 链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (fwd != bck) &#123; <span class="comment">// large bin 对应尺寸的链表不空</span></span><br><span class="line">            size |= PREV_INUSE;</span><br><span class="line">            assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">            <span class="comment">// 如果 victim尺寸比large bin 链表中最后一个chunk尺寸还小 （large bin 链表中的chunk按照从大到下 排列）</span></span><br><span class="line">            <span class="comment">// 则可以将 victim 直接添加到 最后一个chunk的后面 这里只处理了 nextsize 链表 fd bk 的链表需要在下面统一处理</span></span><br><span class="line">            <span class="keyword">if</span> ((unsigned <span class="keyword">long</span>) (size) &lt; (unsigned <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk)) &#123;</span><br><span class="line">                fwd = bck; <span class="comment">// 第一个chunk</span></span><br><span class="line">                bck = bck-&gt;bk; <span class="comment">// 最后一个chunk</span></span><br><span class="line"></span><br><span class="line">                victim-&gt;fd_nextsize = fwd-&gt;fd; <span class="comment">// victim放在最后 形成 循环链表 他的fd 就是 fwd</span></span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; <span class="comment">// fwd-&gt;fd-&gt;bk_nextsize 的当前值就是 bck</span></span><br><span class="line">                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                assert (chunk_main_arena (fwd));</span><br><span class="line">                <span class="comment">// 循环查询 直到size &gt;= nextsize 段的尺寸</span></span><br><span class="line">                <span class="keyword">while</span> ((unsigned <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd)) &#123;</span><br><span class="line">                    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                    assert (chunk_main_arena (fwd));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 尺寸相等并没有处理 nextsize链表，因为这不是必须的，既然相等 那我们不要将其放在 相同尺寸链表中的头部就好了，这样不会影响 nextsize链表</span></span><br><span class="line">                <span class="comment">// 此时只需要将fwd向下移动 然后将 bck 设置到之前fwd的位置 victim就会插入 few 与 bck 之间 ，victim的位置不会是在头部 这样就不影响 nextsize链表</span></span><br><span class="line">                <span class="keyword">if</span> ((unsigned <span class="keyword">long</span>) size == (unsigned <span class="keyword">long</span>) chunksize_nomask (fwd)) fwd = fwd-&gt;fd;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 此时victim尺寸是不与当前链表nextsize中的任何尺寸相等的，将victim添加到 fwd的上面</span></span><br><span class="line">                    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                &#125;</span><br><span class="line">                bck = fwd-&gt;bk; <span class="comment">// 便于下面逻辑处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表为空 victim 是这个链表的唯一一个chunk 所以 nextsize链表中的 fd bk 都指向自己</span></span><br><span class="line">        <span class="keyword">else</span> victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mark_bin (av, victim_index);</span><br><span class="line">    <span class="comment">// 将victim添加到主链表中</span></span><br><span class="line">    victim-&gt;bk = bck;</span><br><span class="line">    victim-&gt;fd = fwd;</span><br><span class="line">    fwd-&gt;bk = victim;</span><br><span class="line">    bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑到性能 尝试不超过 10000 次</span></span><br><span class="line">    <span class="comment">#define MAX_ITERS       10000</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一部分代码需要分析下，当尺寸范围属于 large bin的时候 需要做一些额外的处理，因为 large bin的链表中的chunk尺寸并不相等，他们根据尺寸从大到小排列，为了便于搜索 large bin 的每个链表又维护了一个nextsize链表（fb_nextsize bk_nextsize）<br>这里的逻辑又分为两部分 若尺寸是最小的 则需要将其放在最下面 且重新建立 nextsize 链表的链接，其逻辑结构如下图：<br><img src="WX20190520-205347@2x.png" alt="nextsize 链表操作结构"></p>
<p>若victim的尺寸并不是最小的，则需要遍历nextsize链表 <code>while ((unsigned long) size &lt; chunksize_nomask (fwd)) {fwd = fwd-&gt;fd_nextsize;}</code> 查找到合适的 <code>fwd</code> ，这个时候需要先判断尺寸是否相等 这种情况 如果将victim添加进链表 但是不添加到 一段相同尺寸chunk的头部 就不需要调整 <code>nextsize</code> 链表 ，nextsize链表中的 <code>fd_nextsize</code> <code>bk_nextsize</code> 存储的地址是 <code>一段相同尺寸链的头部和尾部 chunk</code> 所以有代码 <code>if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) fwd = fwd-&gt;fd;</code></p>
<p>其他情况的指针移动则相对简单了，通过 fwd 的地址 将 victim 的 nextsize 指针添加进 <code>fwd</code> 与 <code>fwd-&gt;bk</code> 之间。</p>
<h4 id="3-2-large-bin-查询"><a href="#3-2-large-bin-查询" class="headerlink" title="3.2 large bin 查询"></a>3.2 large bin 查询</h4><p>这段主要是在large bin中循环查询，这个查询是倒叙的，查找到正好大于或等于 nb 的chunk 然后对其切割。切割的一部分返回给用户 另一部分remainder 添加到 unsorted bin 链表里，若剩余部分尺寸不够一个chunk最小尺寸 （MIN_SIZE） 则不进行切割 整个返回给用户<br>这里逻辑相对简单，代码如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">if</span> (!in_smallbin_range (nb)) &#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">// 在large bin 的链表中取第一个chunk 若这个chunk 不为头节点 则说明链表不空</span></span><br><span class="line">    <span class="comment">// 且第一个chunk的尺寸要大于等于请求尺寸 因为第一个chunk是这个链表最大的chunk 若不然 这个链表中的所有chunk都不能满足条件</span></span><br><span class="line">    <span class="built_in">if</span> ((victim = first (bin)) != bin &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)) &#123;</span><br><span class="line">        <span class="comment">// 倒序 先从最小的 chunk开始</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">// 循环 直到找到 victim 正好大于等于 nb 的 chunk段</span></span><br><span class="line">        <span class="built_in">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span> = chunksize (victim)) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))) victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="comment">// 若不是最后一个chunk 且 victim的下一个chunk尺寸与victim相等 则将victim指针移动到下一个 </span></span><br><span class="line">        <span class="comment">// 这里的目的是避免用到第一个chunk 这样会破坏 nextsize链表 多出来重建链表的代码</span></span><br><span class="line">        <span class="built_in">if</span> (victim != last (bin) &amp;&amp; chunksize_nomask (victim) == chunksize_nomask (victim-&gt;fd)) victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里 切割victim的代码单独抽离出来了 看下面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>victim的切割<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多余的尺寸</span></span><br><span class="line">remainder_size = size - nb;</span><br><span class="line"><span class="comment">// 将victim从链表中移除</span></span><br><span class="line">unlink (av, victim, bck, fwd);</span><br><span class="line"><span class="comment">// 剩下部分不够一个最小chunk 则不用切割 整个返回给用户</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena (victim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 切割 victim</span></span><br><span class="line">    <span class="comment">// 剩余chunk部分的地址</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    <span class="comment">/* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here.  */</span></span><br><span class="line">    <span class="comment">// 将剩余部分添加到 unsorted bin 中</span></span><br><span class="line">    bck = unsorted_chunks (av);</span><br><span class="line">    <span class="function"><span class="title">fwd</span> = bck-&gt;</span>fd;</span><br><span class="line">    <span class="function"><span class="title">if</span> (__glibc_unlikely (fwd-&gt;</span>bk != bck)) malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks"</span>);</span><br><span class="line">    <span class="function"><span class="title">remainder</span>-&gt;</span>bk = bck;</span><br><span class="line">    <span class="function"><span class="title">remainder</span>-&gt;</span>fd = fwd;</span><br><span class="line">    <span class="function"><span class="title">bck</span>-&gt;</span>fd = remainder;</span><br><span class="line">    <span class="function"><span class="title">fwd</span>-&gt;</span>bk = remainder;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">        <span class="comment">// 若剩余部分属于 large bin 初始化 nextsize链表指针</span></span><br><span class="line">        <span class="function"><span class="title">remainder</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">        <span class="function"><span class="title">remainder</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置信息</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line">&#125;</span><br><span class="line">check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="comment">// 返回给用户</span></span><br><span class="line">void *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">return p;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-bins-查询"><a href="#3-3-bins-查询" class="headerlink" title="3.3 bins 查询"></a>3.3 bins 查询</h4><p>当上面的过程都没有找到合适的chunk，这里会遍历整个bins查找合适的chunk，查找bins链表中存在的chunk 正好大于用户请求尺寸的chunk 然后对其切割返回。这里涉及到的操作分为两部分 1. bins 链表的查询 2. 切割chunk，其中切割chunk部分的代码跟上一步large bin 的切割是一样的逻辑<br>多出一个处理代码如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="function"><span class="title">remainder</span>-&gt;</span>bk = bck;</span><br><span class="line"><span class="function"><span class="title">remainder</span>-&gt;</span>fd = fwd;</span><br><span class="line"><span class="function"><span class="title">bck</span>-&gt;</span>fd = remainder;</span><br><span class="line"><span class="function"><span class="title">fwd</span>-&gt;</span>bk = remainder;</span><br><span class="line"><span class="comment">// 若用户请求尺寸是在 small bin 的范围内 这时将 remainder 的地址会赋值给 arena 的 last_remainder</span></span><br><span class="line"><span class="function"><span class="title">if</span> (in_smallbin_range (nb)) av-&gt;</span>last_remainder = remainder;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">    <span class="function"><span class="title">remainder</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">    <span class="function"><span class="title">remainder</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure></p>
<p>这里主要需要理解的代码是在查找上，这里使用 bitmap 算法来加快查询。arena结构中有一个属性 <code>unsigned int bitmap[4]</code> 用来表示 bitmap ，其分为4个数组 也就对应 bitmap 的四个段 ，每个段是一个 <code>unsigned int</code> int 需要4个字节 每个字节有8个bit，也就是 bitmap 每个段的长度是 <code>8 * 4 = 32 bit</code>。bitmap总共拥有的 bit 是 32 * 4 = 128 个 这也正对应arena 中的 bins，每个bin是一个chunk链表头部，bit 位用 1 表示 这个链表不空 0 表示链表为空，这样在查询的时候可以直接跳过了，以此实现加速查询，相关的宏如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS            128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT) <span class="comment">// 2^5 = 32</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP) <span class="comment">// 128 / 32 = 4</span></span></span><br><span class="line"><span class="comment">// 计算 bin 中索引对应的bitmap段 也就是 block</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT) <span class="comment">// i / 32</span></span></span><br></pre></td></tr></table></figure></p>
<p>还有一个相对要分析下 <code>#define idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</code>，可以将其拆分成两部分 <code>1U &lt;&lt; [express]</code> 和[express]部分 <code>i &amp; ((1U &lt;&lt; BINMAPSHIFT)-1)</code> 。 [express] 部分其实就是相对于一个段对应bit的偏移量，然后 增加 <code>1U &lt;&lt; [express]</code> 就是偏移量的一种表示 方便下面代码的计算， 比如 偏移量 offset 是 7 则对应的变量bit的值就是  <code>00000000 00000000 00000000 01000000</code><br>代码逻辑如下<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">++idx<span class="comment">;</span></span><br><span class="line"><span class="keyword">bin </span>= <span class="keyword">bin_at </span>(av, idx)<span class="comment">;</span></span><br><span class="line"><span class="keyword">block </span>= idx2block (idx)<span class="comment">;</span></span><br><span class="line"><span class="symbol">map</span> = av-&gt;<span class="keyword">binmap[block];</span></span><br><span class="line"><span class="keyword">bit </span>= idx2bit (idx)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">for</span> (<span class="comment">;; ) &#123;</span></span><br><span class="line">    // 若 <span class="keyword">bit </span>&gt; <span class="meta">map</span> 说明当前<span class="keyword">block中没有合适的链表</span></span><br><span class="line"><span class="keyword"> </span>   // <span class="keyword">bit </span>是以 <span class="number">32</span>bit 中的一位为<span class="number">1</span>表示偏移量 <span class="meta">map</span> 是整个<span class="keyword">block的bin链表的使用情况</span></span><br><span class="line"><span class="keyword"> </span>   // <span class="keyword">bit </span>&gt; <span class="meta">map</span> 说明 <span class="keyword">bit所在的高位对应到 </span><span class="meta">map</span> 一定为 <span class="number">0</span> ，则这个<span class="keyword">block </span>一定没有合适的链表</span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bit </span>&gt; <span class="meta">map</span> <span class="title">||</span> <span class="keyword">bit </span>== <span class="number">0</span>) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 超出 <span class="keyword">bitmap </span>范围说明遍历的整个<span class="keyword">bins </span>链表都是空的 则直接到 use_top的逻辑</span><br><span class="line">            <span class="meta">if</span> (++<span class="keyword">block </span>&gt;= <span class="keyword">BINMAPSIZE) </span>goto use_top<span class="comment">;</span></span><br><span class="line">        &#125; <span class="meta">while</span> ((<span class="meta">map</span> = av-&gt;<span class="keyword">binmap[block]) </span>== <span class="number">0</span>)<span class="comment">; // 若整个bitmap的block都为0 说明整个block中的bin链表都是空的 需要向后再次查询</span></span><br><span class="line">        // 取出<span class="keyword">block中第一个 </span><span class="keyword">bin </span></span><br><span class="line">        <span class="keyword">bin </span>= <span class="keyword">bin_at </span>(av, (<span class="keyword">block </span>&lt;&lt; <span class="keyword">BINMAPSHIFT));</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bit </span>= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这里一定会找到<span class="keyword">bin </span>整个<span class="keyword">block为空的情况 </span>上一步操作会过滤掉 全为空的情况在上面就会 goto user_top<span class="comment">;</span></span><br><span class="line">    // 这里其实循环遍历的是一个<span class="keyword">block的bin</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">while</span> ((<span class="keyword">bit </span>&amp; <span class="meta">map</span>) == <span class="number">0</span>) &#123; // <span class="keyword">bit </span>对应位置链表为空</span><br><span class="line">        // 向后遍历更大尺寸的 <span class="keyword">bin </span>同时移动<span class="keyword">bit位置</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bin </span>= next_bin (<span class="keyword">bin);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bit </span>&lt;&lt;= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="meta">assert</span> (<span class="keyword">bit </span>!= <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    // 读取 <span class="keyword">bin </span>链表中的最后一个chunk</span><br><span class="line">    victim = last (<span class="keyword">bin);</span></span><br><span class="line"><span class="keyword"> </span>   // 若当前的<span class="keyword">bin </span>链表还是空的 <span class="keyword">bitmap的数据有误</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (victim == <span class="keyword">bin) </span>&#123;</span><br><span class="line">        // 修复 <span class="keyword">bitmap的数据</span></span><br><span class="line"><span class="keyword"> </span>       av-&gt;<span class="keyword">binmap[block] </span>= <span class="meta">map</span> &amp;= ~<span class="keyword">bit; </span><span class="comment">/* Write through */</span></span><br><span class="line">        // 到下一个<span class="keyword">bin</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bin </span>= next_bin (<span class="keyword">bin);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bit </span>&lt;&lt;= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span> &#123;</span><br><span class="line">        // victim 切割</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若 bit == 0 或 bit &gt; map 则以段的形式遍历整个bin 如果整个bin链表都是空的 (av-&gt;binmap[block] == 0) 则直接执行 <code>use_top</code> 的代码，若在向后遍历的过程中找到了合适的 block 段 则取出block开始的 bin 并 将bit设置为对应bin的位置(bit = 1) 其中 bit &gt; map 说明当前block中肯定找不到尺寸大于nb且bin链表不为空的链表了。<br>然后就是在 block中进行遍历了 <code>while((bit &amp; map) == 0) {....}</code> ，<code>bit &amp; map</code> 说明bin为空链表 则 向后遍历 bin 这个循环过程是一定会找到合适的bin的。<br>找到合适的bin后 取出链表最后一个 chunk ，这里还进行了判断 链表是否为空 <code>(victim = last(bin)) == bin</code> ，若为空 说明 bitmap 中对应的数据不准确 这时又对这个bitmap中的bit位的值做修复处理 <code>av-bitmap[block] = map &amp; ~ bit</code> 继续向后移动 bin</p>
<p>找到合适的bin后 就做切割处理 这段的代码逻辑和 large bin 中的处理是一样的。</p>
<h2 id="4-切割-top-chunk"><a href="#4-切割-top-chunk" class="headerlink" title="4 切割 top chunk"></a>4 切割 top chunk</h2><p>这一步通过对 top chunk 的切割来分配内存，若不够切割则通过函数 <code>sysmalloc</code> 分配新的 heap_info</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取top chunk的其实地址</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line"><span class="built_in">size</span> = chunksize (victim);</span><br><span class="line"><span class="built_in">if</span> (__glibc_unlikely (<span class="built_in">size</span> &gt; av-&gt;system_mem)) malloc_printerr (<span class="string">"malloc(): corrupted top size"</span>);</span><br><span class="line"><span class="comment">// top chunk 的尺寸足够用来切割</span></span><br><span class="line"><span class="built_in">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">    <span class="comment">// 切割top chunk 剩余部分作为新的 top chunk</span></span><br><span class="line">    remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    <span class="comment">// 返回用户申请部分的chunk</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="built_in">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get here for all block sizes.  */</span></span><br><span class="line"><span class="comment">// 还存在 fast bin</span></span><br><span class="line"><span class="built_in">else</span> <span class="built_in">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks)) &#123;</span><br><span class="line">    <span class="comment">// 合并fastbin中的chunks</span></span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="built_in">if</span> (in_smallbin_range (nb)) idx = smallbin_index (nb);</span><br><span class="line">    <span class="built_in">else</span> idx = largebin_index (nb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Otherwise, relay to handle system-dependent cases */</span></span><br><span class="line"><span class="built_in">else</span> &#123;</span><br><span class="line">    <span class="comment">// top chunk 不够分配的话 调用函数 sysmalloc 增长 arena 的 heap_info </span></span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="built_in">if</span> (p != NULL) alloc_perturb (p, bytes);</span><br><span class="line">    <span class="built_in">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            
                

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/c/">c</a> <a class="tag tag--primary tag--small t-link" href="/tags/glibc/">glibc</a> <a class="tag tag--primary tag--small t-link" href="/tags/malloc/">malloc</a> <a class="tag tag--primary tag--small t-link" href="/tags/ptmalloc/">ptmalloc</a> <a class="tag tag--primary tag--small t-link" href="/tags/内存/">内存</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-sysmalloc创建新的heap-info/"  data-tooltip="malloc源码分析-sysmalloc创建新的heap_info">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-初始化与arena的创建/" data-tooltip="malloc源码分析-初始化与arena的创建">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            
                <div id="ds-thread" class="ds-thread" data-thread-key="2019/05/13/malloc源码分析-int-malloc与chunk合并/"
     data-title="malloc源码分析-int_malloc与chunk合并" data-url="/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
</div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 fantiq. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-sysmalloc创建新的heap-info/"  data-tooltip="malloc源码分析-sysmalloc创建新的heap_info">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-初始化与arena的创建/" data-tooltip="malloc源码分析-初始化与arena的创建">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="3">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-google-plus"></i><span class="">分享到 Google+</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=/2019/05/13/malloc源码分析-int-malloc与chunk合并/">
                <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg"/>
        
            <h4 id="about-card-name">fantiq</h4>
        
            <h5 id="about-card-bio"><p> good at develop framework </p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>developer</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/scrip-gfmrkxcl0qohe3cfdgxhzvc0yrceqta8i4iix0txvn8q4o2adlqd5n0jmkvt.min.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'fantiq'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



</html>
