
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="代码狗的狗窝">
    <title>malloc源码分析-初始化与arena的创建 - 代码狗的狗窝</title>
    <meta name="author" content="fantiq">
    
    
    
    <meta name="description" content="glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias)">
<meta name="keywords" content="c,内存,malloc,glibc,ptmalloc">
<meta property="og:type" content="blog">
<meta property="og:title" content="malloc源码分析-初始化与arena的创建">
<meta property="og:url" content="/2019/05/13/malloc源码分析-初始化与arena的创建/index.html">
<meta property="og:site_name" content="代码狗的狗窝">
<meta property="og:description" content="glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias)">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="/2019/05/13/malloc源码分析-初始化与arena的创建/WX20190517-150525@2x.png">
<meta property="og:image" content="/2019/05/13/malloc源码分析-初始化与arena的创建/WX20190518-230344@2x.png">
<meta property="og:updated_time" content="2019-05-19T03:10:52.107Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="malloc源码分析-初始化与arena的创建">
<meta name="twitter:description" content="glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias)">
<meta name="twitter:image" content="/2019/05/13/malloc源码分析-初始化与arena的创建/WX20190517-150525@2x.png">
    
    
        
    
    
        <meta property="og:image" content="/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-ejlztp1tasruqfvoz6xmgqng0anzae8ox7cqjj5yibieqgcmhe9fwxfae6zj.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">代码狗的狗窝</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg"/>
            </a>
            <span class="sidebar-profile-name">fantiq</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分类</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">搜索</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">关于</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="https://github.com/fantiq"
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            malloc源码分析-初始化与arena的创建
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" content="Mon May 13 2019 15:16:09 GMT+0800">
	
		    5月 13, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/内存/">内存</a>


    
</div>
</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>glibc中的malloc方法其实是映射到 <code>__libc_malloc</code> 的，其通过ASM的符号表的形式来实现<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">strong_alias </span>(__libc_malloc, __malloc) <span class="keyword">strong_alias </span>(__libc_malloc, malloc)</span><br><span class="line"><span class="symbol">define</span> <span class="keyword">strong_alias(original, </span><span class="meta">alias</span>)</span><br><span class="line">  .globl C_SYMBOL_NAME (<span class="meta">alias</span>) ASM_LINE_SEP</span><br><span class="line">  <span class="meta">.set</span> C_SYMBOL_NAME (<span class="meta">alias</span>),C_SYMBOL_NAME (original)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="1-malloc-整体流程"><a href="#1-malloc-整体流程" class="headerlink" title="1. malloc 整体流程"></a>1. malloc 整体流程</h2><p>1<br>以下是祛除一些辅助功能后的代码<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> * __libc_malloc (size_t <span class="built_in">bytes</span>) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="literal">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1 原子的形式调用钩子方法 __malloc_hook 用以初始化 ptmalloc</span></span><br><span class="line">    <span class="literal">void</span> *(*hook) (size_t, const <span class="literal">void</span> *) = atomic_forced_read (__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="built_in">NULL</span>, <span class="number">0</span>)) <span class="keyword">return</span> (*hook)(<span class="built_in">bytes</span>, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 获取 或 创建 arena 并且会将arena 加锁(mutex 互斥锁)处理</span></span><br><span class="line">    arena_get (ar_ptr, <span class="built_in">bytes</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptmalloc 核心逻辑</span></span><br><span class="line">    victim = _int_malloc (ar_ptr, <span class="built_in">bytes</span>);</span><br><span class="line">    <span class="comment">/* Retry with another arena only if we were able to find a usable arena before.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ar_ptr 指定的 arena不为空 也就是说 arena_get 获取arena是成功的 但是 _int_malloc 方法返回的 victim 却为空 这里会重新获取一遍arena arena_get_retry</span></span><br><span class="line">    <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="built_in">NULL</span>) &#123;</span><br><span class="line">        LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, <span class="built_in">bytes</span>);</span><br><span class="line">        ar_ptr = arena_get_retry (ar_ptr, <span class="built_in">bytes</span>);</span><br><span class="line">        victim = _int_malloc (ar_ptr, <span class="built_in">bytes</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除arena的互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (ar_ptr != <span class="built_in">NULL</span>) __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">    <span class="comment">// 返回内存地址给用户</span></span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__libc_malloc</code> 整体流程分如下几步：</p>
<ol>
<li>通过钩子函数 <code>__malloc_hook</code> 先初始化 <code>ptmalloc</code> 且只会初始化一次</li>
<li>通过 arena_get 获取当前线程的 arena 如果不存在当前线程的arena则创建一个arena返回 且 这一步还给arena加上互斥锁</li>
<li>调用核心逻辑 _int_malloc 查询chunk </li>
<li>如果arena获取成功 上一步却没找到chunk 则通过arena_get_retry 尝试再次分配</li>
<li>查询成功解锁arena 返回地址给用户</li>
</ol>
<p>这里需要展开的函数有 <code>__malloc_hook</code> <code>arena_get</code> <code>_int_malloc</code> 其中<code>_int_malloc</code> 作为核心函数 代码量比较大 会放在下一章进行详细分析，这里主要分析 <code>__malloc_hook</code> <code>__malloc_hook</code></p>
<h2 id="2-malloc-hook-初始化ptmalloc"><a href="#2-malloc-hook-初始化ptmalloc" class="headerlink" title="2. __malloc_hook 初始化ptmalloc"></a>2. <code>__malloc_hook</code> 初始化ptmalloc</h2><h4 id="2-1-malloc初始化调用逻辑"><a href="#2-1-malloc初始化调用逻辑" class="headerlink" title="2.1 malloc初始化调用逻辑"></a>2.1 malloc初始化调用逻辑</h4><p>malloc初始化调用的钩子方法 定义如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *weak_variable <span class="comment">(*__malloc_hook) (size_t __size, const void *)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure></p>
<p>这里通过 <code>weak_variable</code> 进行修饰，为了方便用户对这个钩子方法的替换，这个钩子方法指定到了 函数 malloc_hook_ini，源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">malloc_hook_ini</span> <span class="params">(<span class="keyword">size_t</span> sz, <span class="keyword">const</span> <span class="keyword">void</span> *caller)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空malloc钩子方法的绑定</span></span><br><span class="line">    __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 调用初始化方法</span></span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">    <span class="comment">// 从新走 __libc_malloc 方法</span></span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当函数执行进来则会将钩子函数的变量设置为 NULL 也是为了保证这个初始化函数只会被调用一次，初始化的主要代码还是在函数 <code>ptmalloc_init</code> ，初始化完毕还是会调用函数 <code>__libc_malloc</code></p>
<h4 id="2-2-ptmalloc-init"><a href="#2-2-ptmalloc-init" class="headerlink" title="2.2 ptmalloc_init"></a>2.2 ptmalloc_init</h4><p>下面是初始化的代码，这里主要为了看逻辑过程 删除了一些配置相关的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __thread mstate thread_arena attribute_tls_model_ie;</span><br><span class="line"><span class="keyword">int</span> __malloc_initialized = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ptmalloc_init</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果执行过或者正在执行中这个方法则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __malloc_initialized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">        <span class="comment">/* In case this libc copy is in a non-default namespace, never use brk. Likewise if dlopened from statically linked program.  */</span></span><br><span class="line">        Dl_info di;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span> || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span> &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) __morecore = __failing_morecore;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// thread_arena 记录当前线程的arena指针地址 ptmalloc_init 中指定的是主线程的arena</span></span><br><span class="line">    thread_arena = &amp;main_arena;</span><br><span class="line">    <span class="comment">// 这里对主线程的 arena 进行初始化</span></span><br><span class="line">    malloc_init_state (&amp;main_arena);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里省略了一些配置项设置的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化执行完毕 将变量 __malloc_initialized 赋值为1</span></span><br><span class="line">    __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结合上面的逻辑可以看出来，初始化的线程一定是主线程，所以这里的当前线程就是 main_arena  <code>thread_arena = &amp;main_arena</code>，然后会通过函数 <code>malloc_init_state</code> 初始化一些值。<br>此方法开始的时候设置 <code>__malloc_initialized=0</code> 结束的时候设置 <code>__malloc_initialized=1</code> 。主要的初始化代码在函数 <code>malloc_init_state</code><br>需要注意下其中变量 thread_arena 的定义 <code>static __thread mstate thread_arena attribute_tls_model_ie;</code> 变量通过关键词 <code>__thread</code> 进行修饰，也就是说这个全局变量是针对每一个线程的，每一个线程都拥有一个这样的全局变量 且 与其他线程隔离。<br>也就是说 新的线程调用此方法的时候 其 thread_arena 为 NULL 这个会在获取 arena 的函数中用到。</p>
<h4 id="2-3-malloc-init-state"><a href="#2-3-malloc-init-state" class="headerlink" title="2.3 malloc_init_state"></a>2.3 malloc_init_state</h4><p>对arena的初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4) <span class="comment">// 16 * 8 = 128</span></span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_init_state</span> <span class="params">(mstate av)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">    <span class="comment">// 初始化 arena的 bin 列表 bin的作用就是 一个缓冲区 方便查询</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at (av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 主线程arena 设置 XXX</span></span><br><span class="line">            set_noncontiguous (av);</span><br><span class="line">    <span class="comment">// 主线程arena设置 fastbin的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena) set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line">    av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数 <code>malloc_init_state</code> 做的初始化功能主要有 初始化 arena 的 bins、如果是主线程 设置fastbin的最大值 以及 初始化 top<br>先看top的初始化<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define initial_top(<span class="name">M</span>)              (<span class="name">unsorted_chunks</span> (<span class="name">M</span>))</span><br><span class="line">#define unsorted_chunks(<span class="name">M</span>)          (<span class="name">bin_at</span> (<span class="name">M</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>top的初始化最终调用的还是 宏 <code>bin_at</code> 不同的是 top 固定了其index为1 所以我们重点关注 宏 <code>bin_at</code></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define bin_at(m, i) (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>])) - offsetof (struct malloc_chunk, fd))</span><br><span class="line"><span class="comment">// 将其简化则如下</span></span><br><span class="line">&amp;bins[(i<span class="number">-1</span>)*<span class="number">2</span>] - <span class="number">8</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bins 的定义</span></span><br><span class="line">typedef struct malloc_chunk* mchunkptr;</span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>从上面的定义关系中其实可以得出 <code>&amp;bins[(i-1)*2]</code> 得出的其实是一个地址 在x64上占8个字节，后面的 <code>- 8*2</code> 相当于在数组上向左移动两个位置 最后我们得到 i 与 实际得到的值的关系是 <code>(i-2)*2</code> 结合代码<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span> (i = <span class="number">1</span><span class="comment">; i &lt; NBINS; ++i) &#123;</span></span><br><span class="line">    <span class="keyword">bin </span>= <span class="keyword">bin_at(av, </span>i)<span class="comment">; // 这里指向 的是 bins 数组索引 (i-2)*2</span></span><br><span class="line">    <span class="keyword">bin-&gt;fd </span>= <span class="keyword">bin-&gt;bk </span>= <span class="keyword">bin; </span>// 这里再调用 <span class="keyword">bin-&gt;fd </span><span class="keyword">bin-&gt;bk </span>其实是在移动上一步得到的地址 通过 malloc_chunk 可以得出 fd 右位移<span class="number">2</span>个位置 <span class="keyword">bk </span>右位移<span class="number">3</span>个位置 这个时候就很容易理解为什么<span class="keyword">bin_at </span>的宏定义中要 ` - offsetof (<span class="keyword">struct </span>malloc_chunk, fd)` 了</span><br><span class="line">    // 也就是说通过<span class="keyword">bin_at </span>得到偏移后的地址 通过 <span class="keyword">bin-&gt;fb </span>正好又偏移回来了 也就是说 i = <span class="number">1</span> 时 idx <span class="number">0</span> 是<span class="keyword">bin_at(1)-&gt;fd </span>idx <span class="number">1</span> 是<span class="keyword">bin_at(1)-&gt;bk</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>其实最终得到的 bins 的结构如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr idx   <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span>   <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span>   ..............   <span class="number">249</span>  <span class="number">250</span>  <span class="number">251</span>  <span class="number">252</span>  <span class="number">253</span> <span class="number">254</span></span><br><span class="line">        +---------+---------+---------+----------------+---------+---------+---------+</span><br><span class="line">        | fd | bk | fd | bk | fd | bk | .............. | fd | bk | fd | bk | fd | bk |</span><br><span class="line">        +---------+---------+---------+----------------+---------+---------+---------+</span><br><span class="line">         bin_at(<span class="number">1</span>) bin_at(<span class="number">2</span>) bin_at(<span class="number">3</span>)     bin_at(N)   bin_at(<span class="number">125</span>) bin_at(<span class="number">126</span>) bin_at(<span class="number">127</span>)</span><br></pre></td></tr></table></figure></p>
<p>这样一个结构 将来是要承载 smallbin largebin unsortedbin 这三种bin链表的，初始化的时候并没有指向到一个malloc_chunk 地址 而是初始化了数组的地址 后面判断 一个bin是否为空链表的时候会用到这个进行判断</p>
<h2 id="3-arena-的创建"><a href="#3-arena-的创建" class="headerlink" title="3. arena 的创建"></a>3. arena 的创建</h2><p>arena创建这部分是整个malloc中比较重要的一部分了，在malloc代码通过宏 <code>arena_get</code> 实现，<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define arena_get(ptr, size) </span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ptr</span> = thread_arena<span class="comment">;</span></span><br><span class="line">    arena_lock (<span class="built_in">ptr</span>, size)<span class="comment">;</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#define arena_lock(ptr, size)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ptr</span>) __libc_lock_lock (<span class="built_in">ptr</span>-&gt;mutex)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ptr</span> = arena_get2 ((size), <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">// 合并之后的代码</span><br><span class="line"><span class="built_in">ptr</span> = thread_arena<span class="comment">;</span></span><br><span class="line">// 如果当前线程arena不为空 则给当前线程加互斥锁</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ptr</span>) __libc_lock_lock (<span class="built_in">ptr</span>-&gt;mutex)<span class="comment">;</span></span><br><span class="line">// 当前线程arena为空 说明当前线程是刚刚创建 需要给当前线程创建arena</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">ptr</span> = arena_get2 ((size), <span class="literal">NULL</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>所以这里代码的重点是 给当前线程创建 arena 也就是调用方法 <code>arena_get2</code></p>
<h4 id="3-1-arena-get2"><a href="#3-1-arena-get2" class="headerlink" title="3.1 arena_get2"></a>3.1 arena_get2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> narenas = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> mstate <span class="title">arena_get2</span> <span class="params">(<span class="keyword">size_t</span> size, mstate avoid_arena)</span> </span>&#123;</span><br><span class="line">    mstate a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> narenas_limit;</span><br><span class="line">    <span class="comment">// 读取free_list</span></span><br><span class="line">    a = get_free_list ();</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">        <span class="comment">// 这里是给静态变量 narenas_limit 进行初始化值</span></span><br><span class="line">        <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// arena_max有值则使用arena_max的值</span></span><br><span class="line">            <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>) narenas_limit = mp_.arena_max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = __get_nprocs (); <span class="comment">// 读取CPU核数</span></span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">1</span>) narenas_limit = NARENAS_FROM_NCORES (n); <span class="comment">// ((n) * (sizeof (long) == 4 ? 2 : 8)) -&gt; cpu核数 * [2(x32)|8(x64)]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/* We have no information about the system.  Assume two cores.  */</span></span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        repeat:;</span><br><span class="line">        <span class="keyword">size_t</span> n = narenas;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n)) <span class="keyword">goto</span> repeat;</span><br><span class="line">            a = _int_new_arena (size);</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>)) catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有空闲arena 则直接返回了</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要有以下几个步骤</p>
<ol>
<li>通过函数 get_free_list 获取arena 如果获取到则直接返回 获取不到则继续往下进行</li>
<li>通过内核数量计算出来arena数量最大值 narenas_limit = cpu核数 * 2/8 (x32/x64)</li>
<li>通过 narenas 与 narenas_limit 确定是通过 <code>_int_new_arena</code> 创建新的 arena 还是 通过 reused_arena 利用现有的arena</li>
</ol>
<p>接下来要着重分析的是 <code>get_free_list</code> <code>reused_arena</code> <code>_int_new_arena</code> 这三个函数 </p>
<h4 id="3-2-get-free-list-从free-list查找arena"><a href="#3-2-get-free-list-从free-list查找arena" class="headerlink" title="3.2 get_free_list 从free_list查找arena"></a>3.2 get_free_list 从free_list查找arena</h4><p>从 free_list 中获取一个合适的 arena，free_list 是指向链表头部的指针，这个链表是由 malloc_state中的属性 <code>next_free</code> 链接的<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free_list 是一个malloc_state的指针 用以做成链表</span></span><br><span class="line">typedef struct malloc_state *mstate;</span><br><span class="line"><span class="keyword">static</span> mstate free_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> mstate get_free_list (void) &#123;</span><br><span class="line">    <span class="comment">// 当前线程arena</span></span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    mstate result = free_list;</span><br><span class="line">    <span class="comment">/*读取free_list 这个链表是从 fork调用 时候从父进程copy过来的，如果是在父进程中则free_list 一直为 NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        __libc_lock_lock (free_list_lock);</span><br><span class="line">        <span class="comment">// 将free_list 指向的malloc_state 从 malloc_state的next_free 组成的链表中取出</span></span><br><span class="line">        result = free_list;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            free_list = result-&gt;next_free;</span><br><span class="line">            <span class="comment">/* The arena will be attached to this thread.  */</span></span><br><span class="line">            assert (result-&gt;attached_threads == <span class="number">0</span>);</span><br><span class="line">            result-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">            detach_arena (replaced_arena); <span class="comment">// 将当前线程指向的 malloc_state 中的属性 attached_threads 减一 因为下面要将当前线程换成从 free_list 中获取的arena</span></span><br><span class="line">        &#125;</span><br><span class="line">        __libc_lock_unlock (free_list_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            LIBC_PROBE (memory_arena_reuse_free_list, <span class="number">1</span>, result);</span><br><span class="line">            __libc_lock_lock (result-&gt;mutex);</span><br><span class="line">            <span class="comment">// 取出的arena作为当前线程的arena</span></span><br><span class="line">            thread_arena = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若free_list 为 NULL 则直接返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 replaced_arena 不为空 则将其attached_threads 减一</span></span><br><span class="line"><span class="keyword">static</span> void detach_arena (mstate replaced_arena) &#123;</span><br><span class="line">    <span class="keyword">if</span> (replaced_arena != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        assert (replaced_arena-&gt;attached_threads &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* The current implementation only detaches from main_arena in case of allocation failure.  </span></span><br><span class="line"><span class="comment">        This means that it is likely not beneficial to put the arena on free_list even if the reference count reaches zero.  */</span></span><br><span class="line">        --replaced_arena-&gt;attached_threads;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题是 free_list 的数据是从哪里产生的呢，是从系统调用中的 <code>fork</code> 方法产生的，由于linux中线程之间是共享内存的 而进程之间是不共享的，使用 <code>fork</code>创建新的进程的时候 系统会复制一份父进程的内存到子进程中。系统的 <code>fork</code> 方法经过层层调用 最终调用的函数是 <code>__malloc_fork_unlock_child</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void __malloc_fork_unlock_child (void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ptmalloc_init 没有调用过 也就是说 ptmalloc没有初始化</span></span><br><span class="line">    <span class="keyword">if</span> (__malloc_initialized &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* Push all arenas to the free list, except thread_arena, which is attached to the current thread.  */</span></span><br><span class="line">    __libc_lock_init (free_list_lock);</span><br><span class="line">    <span class="keyword">if</span> (thread_arena != <span class="keyword">NULL</span>) thread_arena-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 free_list 变量</span></span><br><span class="line">    free_list = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="comment">// 从主线程arena开始</span></span><br><span class="line">    <span class="keyword">for</span> (mstate ar_ptr = &amp;main_arena;; ) &#123;</span><br><span class="line">        __libc_lock_init (ar_ptr-&gt;mutex);</span><br><span class="line">        <span class="comment">/*  free_list 作为一个链表的头指针，通过循环 arean_list 将他们组织到 一个 free_list 指引的链表上</span></span><br><span class="line"><span class="comment">            这些arena 都是从父进程中copy过来的 */</span></span><br><span class="line">        <span class="keyword">if</span> (ar_ptr != thread_arena) &#123;</span><br><span class="line">            <span class="comment">/* This arena is no longer attached to any thread.  */</span></span><br><span class="line">            ar_ptr-&gt;attached_threads = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 通过 free_list 将这些arena通过next_free 串联成链表</span></span><br><span class="line">            ar_ptr-&gt;next_free = free_list;</span><br><span class="line">            free_list = ar_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动到下一个 arena</span></span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="comment">// 如果到了主线程arena 说明循环了一圈 结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __libc_lock_init (list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-reused-arena-重用arena"><a href="#3-3-reused-arena-重用arena" class="headerlink" title="3.3 reused_arena 重用arena"></a>3.3 reused_arena 重用arena</h4><p>这个方法是从当前进程中的 arena 列表中查询可用的arena 进行接下来的内存分配。其思路是 先通过main_arena 为起点循环遍历 arena 链表，对链表中的arena进行加锁尝试 如果失败则循环到下一个arena 如果成功 将当前线程的arena引用变量 thread_arena替换为当前的arena。<br>替换过程需要做一定的处理 </p>
<ol>
<li>替换前的thread_arena 的属性 attached_thread需要减一 </li>
<li>将当前arena从free_list 中移除 将当前arena的attached_thread 加一 </li>
<li>给 thread_arena赋值并返回 最后还会移动下 next_to_use 方便下次使用<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> mstate reused_arena (mstate avoid_arena) &#123;</span><br><span class="line">    mstate result;</span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">    <span class="comment">// 初始化静态变量 next_to_use 为 &amp;main_arena</span></span><br><span class="line">    <span class="keyword">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="keyword">NULL</span>) next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate over all arenas (including those linked from free_list).  */</span></span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="comment">// 从main_arena开始循环arena链表 直到循环一圈停止查询。在循环过程中 尝试给arena加锁 加锁成功则执行 out 代码片段，另外 __libc_lock_trylock 不会等待锁的 拿不到锁会立刻返回</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!__libc_lock_trylock (result-&gt;mutex)) <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Avoid AVOID_ARENA as we have already failed to allocate memory in that arena and it is currently locked.   */</span></span><br><span class="line">    <span class="keyword">if</span> (result == avoid_arena) result = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No arena available without contention.  Wait for the next in line.  */</span></span><br><span class="line">    LIBC_PROBE (memory_arena_reuse_wait, <span class="number">3</span>, &amp;result-&gt;mutex, result, avoid_arena);</span><br><span class="line">    __libc_lock_lock (result-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attach the arena to the current thread.  */</span></span><br><span class="line">    out:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Update the arena thread attachment counters.   */</span></span><br><span class="line">            mstate replaced_arena = thread_arena;</span><br><span class="line">            __libc_lock_lock (free_list_lock);</span><br><span class="line">            detach_arena (replaced_arena); <span class="comment">// 将这个arena的attached_thread 减一 因为thread_arena 需要更换</span></span><br><span class="line">            <span class="comment">// 将result从free_list 中去除</span></span><br><span class="line">            remove_from_free_list (result);</span><br><span class="line">            <span class="comment">// 新的thread_arean 加一</span></span><br><span class="line">            ++result-&gt;attached_threads;</span><br><span class="line">            __libc_lock_unlock (free_list_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    LIBC_PROBE (memory_arena_reuse, <span class="number">2</span>, result, avoid_arena);</span><br><span class="line">    <span class="comment">// 替换 thread_arena</span></span><br><span class="line">    thread_arena = result;</span><br><span class="line">    <span class="comment">// 将 next_to_use 移动到下一个</span></span><br><span class="line">    next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void remove_from_free_list (mstate arena) &#123;</span><br><span class="line">    mstate *previous = &amp;free_list;</span><br><span class="line">    <span class="comment">// 循环 free_list</span></span><br><span class="line">    <span class="keyword">for</span> (mstate p = free_list; p != <span class="keyword">NULL</span>; p = p-&gt;next_free) &#123;</span><br><span class="line">        assert (p-&gt;attached_threads == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p == arena) &#123; <span class="comment">// 在free_list 的链表上找到参数 arena</span></span><br><span class="line">            <span class="comment">/* Remove the requested arena from the list.  */</span></span><br><span class="line">            *previous = p-&gt;next_free;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> previous = &amp;p-&gt;next_free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-4-int-new-arena-新建arena"><a href="#3-4-int-new-arena-新建arena" class="headerlink" title="3.4 _int_new_arena 新建arena"></a>3.4 <code>_int_new_arena</code> 新建arena</h4><p>新建一个arena 每个arena都是有若干个 heap 组成的 heap 通过 <code>new_heap</code> 创建，然后就是要设置一些 malloc_state 的参数<br>重要的是 这里创建的 top 后面的内存分配会从top上切割产生，后面有了 bins 的缓存则会从缓存中获取<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate _int_new_arena (size_t <span class="built_in">size</span>) &#123;</span><br><span class="line">    mstate a;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> misalign;</span><br><span class="line">    <span class="comment">// 创建 sub_heap 其实 new_heap 是申请内存 这里将 malloc_state top_pad heap_info 和 size 全包含进去 申请内存了</span></span><br><span class="line">    <span class="comment">// 多申请 MALLOC_ALIGNMENT 这段内存的目的是 下面对齐的时候需要用到的 怕内存不够</span></span><br><span class="line">    h = new_heap (<span class="built_in">size</span> + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br><span class="line">    <span class="built_in">if</span> (!h) &#123;</span><br><span class="line">        <span class="comment">// 创建失败 再次尝试创建 再不成功直接返回</span></span><br><span class="line">        h = new_heap (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">        <span class="built_in">if</span> (!h) <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给heap设置 arena 指针</span></span><br><span class="line">    a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化 arena的bins</span></span><br><span class="line">    malloc_init_state (a);</span><br><span class="line">    a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">    a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">    <span class="comment">// 新建的arena 初始化arena 初始化top且内存尺寸对齐</span></span><br><span class="line">    <span class="comment">// 这里可以看到 当新建一个arena的时候其里面的chunk只有一个top chunk</span></span><br><span class="line">    ptr = (<span class="keyword">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// misalign 是向下对齐多出来的长度</span></span><br><span class="line">    misalign = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">    <span class="comment">// 先上对齐</span></span><br><span class="line">    <span class="built_in">if</span> (misalign &gt; <span class="number">0</span>) ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">    <span class="comment">// 设置 top chunk</span></span><br><span class="line">    top (a) = (mchunkptr) ptr;</span><br><span class="line">    set_head (top (a), (((<span class="keyword">char</span> *) h + h-&gt;<span class="built_in">size</span>) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    LIBC_PROBE (memory_arena_new, <span class="number">2</span>, a, <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">// 切换 thread_arena </span></span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    thread_arena = a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前新的arena 加锁 添加到arena链表 </span></span><br><span class="line">    __libc_lock_init (a-&gt;mutex);</span><br><span class="line">    __libc_lock_lock (list_lock);</span><br><span class="line">    <span class="comment">// 添加arena到链表</span></span><br><span class="line">    a-&gt;next = main_arena.next;</span><br><span class="line">    atomic_write_barrier ();</span><br><span class="line">    main_arena.next = a;</span><br><span class="line">    __libc_lock_unlock (list_lock);</span><br><span class="line">    __libc_lock_lock (free_list_lock);</span><br><span class="line">    detach_arena (replaced_arena);</span><br><span class="line">    __libc_lock_unlock (free_list_lock);</span><br><span class="line">    <span class="comment">// arena增加互斥锁</span></span><br><span class="line">    __libc_lock_lock (a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>着重看下 在 <code>new_heap</code> 申请完内存后 在函数 <code>_int_new_arena</code> 中对这段内存的划分部分 以及top 部分<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h 指向 new_heap 申请到的内存地址起始位置 并且类型是被转成 heap_info 后返回的，这里 h+1 正好是到 h分配完类型 heap_info 成员占用内存后的位置</span></span><br><span class="line"><span class="comment">// 且通过类型转换 将后面的内存又划分出了一部分malloc_state 的内存</span></span><br><span class="line">a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">ptr = (<span class="keyword">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 这里是做内存对齐的操作</span></span><br><span class="line">misalign = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line"><span class="built_in">if</span> (misalign &gt; <span class="number">0</span>) ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line"><span class="comment">// 开始分配top部分</span></span><br><span class="line">top (a) = (mchunkptr) ptr;</span><br><span class="line">set_head (top (a), (((<span class="keyword">char</span> *) h + h-&gt;<span class="built_in">size</span>) - ptr) | PREV_INUSE);</span><br></pre></td></tr></table></figure></p>
<p>内存划分后的情况如下图所示：<br><img src="WX20190517-150525@2x.png" alt="内存分配情况"><br>对于top部分的处理 宏 进行展开分析<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="function"><span class="title">define</span> top(ar_ptr) ((ar_ptr)-&gt;</span>top)</span><br><span class="line">#<span class="function"><span class="title">define</span> set_head(p, s)       ((p)-&gt;</span>mchunk_size = (s))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应代码展开如下</span></span><br><span class="line">ptr = (char *) (a + <span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="title">a</span>-&gt;</span>top = (mchunkptr) ptr; <span class="comment">// 确定指针位置</span></span><br><span class="line"><span class="comment">// h + size - ptr 这就是剩下的空闲空间的长度</span></span><br><span class="line"><span class="function"><span class="title">a</span>-&gt;</span><span class="function"><span class="title">top</span>-&gt;</span><span class="function"><span class="title">mchunk_size</span> = (((char *) h + h-&gt;</span>size) - ptr) | PREV_INUSE; <span class="comment">// 设置 top chunk 的 mchunk_size 字段 设置chunk大小 以及 设置 prev_inuse 为已使用(其实这个时候 top chunk 前面并没有 chunk ，设置为已使用是为了后面chunk合并的时候 有一个结束条件)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-new-heap-新建arena-的-sub-heap"><a href="#3-5-new-heap-新建arena-的-sub-heap" class="headerlink" title="3.5 new_heap 新建arena 的 sub_heap"></a>3.5 <code>new_heap</code> 新建arena 的 sub_heap</h4><p>每个arena 是 由多个行程链表的 heap组成的 称作 sub_heap 吧，其创建的整体逻辑如下注释:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> heap_info * new_heap (size_t <span class="built_in">size</span>, size_t top_pad) &#123;</span><br><span class="line">    <span class="comment">// 获取系统内存管理的基本尺寸 一般为 4K 这个值可以在 glibc中的全局变量中找到</span></span><br><span class="line">    size_t pagesize = GLRO (dl_pagesize); <span class="comment">// 4K</span></span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对size进行处理</span></span><br><span class="line"><span class="comment">    如果size + top_pad 小于 HEAP_MIN_SIZE 则使用最小值</span></span><br><span class="line"><span class="comment">    如果size + top_pad 小于或等于HEAP_MAX_SIZE 则size = size + top_pad</span></span><br><span class="line"><span class="comment">    如果size 大于 HEAP_MAX_SIZE 则 return 0 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">size</span> + top_pad &lt; HEAP_MIN_SIZE) <span class="built_in">size</span> = HEAP_MIN_SIZE;</span><br><span class="line">    <span class="built_in">else</span> <span class="built_in">if</span> (<span class="built_in">size</span> + top_pad &lt;= HEAP_MAX_SIZE) <span class="built_in">size</span> += top_pad;</span><br><span class="line">    <span class="built_in">else</span> <span class="built_in">if</span> (<span class="built_in">size</span> &gt; HEAP_MAX_SIZE) <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">else</span> <span class="built_in">size</span> = HEAP_MAX_SIZE;</span><br><span class="line">    <span class="built_in">size</span> = ALIGN_UP (<span class="built_in">size</span>, pagesize); <span class="comment">// 4K对齐</span></span><br><span class="line"></span><br><span class="line">    p2 = MAP_FAILED;</span><br><span class="line">    <span class="comment">// 如果上次分配内存计算出了下次内存分配的起始地址 这里合一直接分配了 减少一定的计算量与内核态的切换</span></span><br><span class="line">    <span class="built_in">if</span> (aligned_heap_area) &#123;</span><br><span class="line">        <span class="comment">// 直接基于aligned_heap_area作为起始地址分配</span></span><br><span class="line">        p2 = (<span class="keyword">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        <span class="comment">// 清除了</span></span><br><span class="line">        aligned_heap_area = NULL;</span><br><span class="line">        <span class="comment">// 分配失败 返还申请的内存</span></span><br><span class="line">        <span class="built_in">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>))) &#123;</span><br><span class="line">            __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">            p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里通过mmap申请内存，成功会返回申请的内存段的起始地址。且这里想要将内存地址的起始与结束的地址是与 HEAP_MAX_SIZE 对齐的 内存长度是 HEAP_MAX_SIZE。</span></span><br><span class="line"><span class="comment">    这里会看到先申请了两倍 HEAP_MAX_SIZE 尺寸的内存，这是怕 当返回的地址不是内存对齐的，这个时候需要向后调整内存地址 使内存起始地址与 HEAP_MAX_SIZE 对齐</span></span><br><span class="line"><span class="comment">    这里向后是因为前面的地址可能已经被其他程序申请，然后又要保持内存长度是 HEAP_MAX_SIZE ，这样前面申请的 HEAP_MAX_SIZE 长度内存就不够了，需要再次调用mmap</span></span><br><span class="line"><span class="comment">    为了减少调用 这里申请了两倍的内存 然后将多余的通过 __munmap 还回去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">if</span> (p2 == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 申请 两倍 HEAP_MAX_SIZE 长度的内存 p1是内核返回的内存起始地址</span></span><br><span class="line">        p1 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        <span class="built_in">if</span> (p1 != MAP_FAILED) &#123; <span class="comment">// 分配成功 对内存尺寸进行调整 使其在 HEAP_MAX_SIZE长度的内存段上</span></span><br><span class="line">            <span class="comment">// p1 针对HEAP_MAX_SIZE向上对齐</span></span><br><span class="line">            p2 = (<span class="keyword">char</span> *) (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p1 + (HEAP_MAX_SIZE - <span class="number">1</span>)) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>));</span><br><span class="line">            ul = p2 - p1;<span class="comment">//由于是向上 所以是 p2 - p1，若 ul = 0 说明 mmap分配的起始地址恰好是HEAP_MAX_SIZE对齐的，不然就需要调整 </span></span><br><span class="line">            <span class="built_in">if</span> (ul) __munmap (p1, ul); <span class="comment">// 返还起始地址向上偏移后多出来的地址</span></span><br><span class="line">            <span class="built_in">else</span> aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">            <span class="comment">// 返还由于 两倍HEAP_MAX_SIZE 多出来的部分 只需要 HEAP_MAX_SIZE 长度的内存就好了</span></span><br><span class="line">            __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE is already aligned. */</span></span><br><span class="line">            <span class="comment">// 两倍内存申请不到，这里只好申请 HEAP_MAX_SIZE 内存 碰碰运气了</span></span><br><span class="line">            p2 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">            <span class="built_in">if</span> (p2 == MAP_FAILED) <span class="built_in">return</span> <span class="number">0</span>; <span class="comment">// 分配失败</span></span><br><span class="line">            <span class="comment">// 运气不好 返回的地址 并不能与HEAP_MAX_SIZE对齐 这里只好返回申请的内存 并结束</span></span><br><span class="line">            <span class="built_in">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)) &#123;</span><br><span class="line">                __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">                <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置读写权限</span></span><br><span class="line">    <span class="built_in">if</span> (__mprotect (p2, <span class="built_in">size</span>, PROT_READ | PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">        <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一些heap参数 返回这个申请的heap</span></span><br><span class="line">    h = (heap_info *) p2;</span><br><span class="line">    h-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    h-&gt;mprotect_size = <span class="built_in">size</span>;</span><br><span class="line">    LIBC_PROBE (memory_heap_new, <span class="number">2</span>, h, h-&gt;<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先看参数处理部分，相关的宏定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_MIN_SIZE (32 * 1024) <span class="comment">// 32K</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) <span class="comment">// x64 上是64M</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long)) <span class="comment">// 4 * [4|8] M</span></span></span><br></pre></td></tr></table></figure></p>
<p>保持size的大小在 HEAP_MIN_SIZE 与 HEAP_MAX_SIZE 之间</p>
<p>然后是 <code>size_t pagesize = GLRO (dl_pagesize);</code> 展开宏<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLRO(name) _##name <span class="comment">// _dl_pagesize</span></span></span><br><span class="line"><span class="comment">/* Cached value of `getpagesize ()'.  */</span></span><br><span class="line">EXTERN <span class="keyword">size_t</span> _dl_pagesize;</span><br><span class="line"><span class="keyword">size_t</span> _dl_pagesize = EXEC_PAGESIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXEC_PAGESIZE   4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终的形式是</span></span><br><span class="line"><span class="keyword">size_t</span> pagesize = EXEC_PAGESIZE;<span class="comment">// 4096 byte  也就是 4k</span></span><br></pre></td></tr></table></figure></p>
<p>然后是补齐的算法<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 补齐算法 <span class="built_in">size</span> + <span class="built_in">size</span>&amp;(base-<span class="number">1</span>)</span><br><span class="line">#define ALIGN_UP(base, <span class="built_in">size</span>)    ALIGN_DOWN ((base) + (<span class="built_in">size</span>) - <span class="number">1</span>, (<span class="built_in">size</span>))</span><br><span class="line">#define ALIGN_DOWN(base, <span class="built_in">size</span>)  ((base) &amp; -((__typeof__ (base)) (<span class="built_in">size</span>))) // base &amp; -<span class="built_in">size</span></span><br></pre></td></tr></table></figure></p>
<p>这段主要是通过 mmap 申请内存 使用到的一个重要的方法是 mmap 函数原型 <code>void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset)</code> 和 <code>int munmap(void* start, size_t length)</code> ，mmap 分配内存 munmap 释放内存，这些操作都是要切到内核态执行的，<br>|参数|例子|意义|<br>|–|–|–|<br>|void* start|NULL|内存分配开始的位置 写NULL 这个位置由内核决定|<br>|size_t length|[number]|分配内存的长度|<br>|int prot|PROT_EXEC:执行 PROT_READ:读 PROT_WRITE:写 PROT_NONE:不可访问|权限|<br>|int flags||文件类型 需要与 open 的时候使用的配对儿|<br>|int fd|-1|文件句柄 -1 是与匿名搭配使用|<br>|off_t offset|0|写入文件的偏移量|<br>这里代码逻辑的设计也是为了减少内核函数的调用，先看其如何通过一系列宏调用系统函数的<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">MMAP_CALL</span>(__nr, __addr, __len, __prot, __flags, __fd, __offset) <span class="selector-tag">INLINE_SYSCALL_CALL</span> (__nr, __addr, __len, __prot, __flags, __fd, __offset)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">INLINE_SYSCALL_CALL</span>(...) <span class="selector-tag">__INLINE_SYSCALL_DISP</span> (__INLINE_SYSCALL, __VA_ARGS__)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">__INLINE_SYSCALL_DISP</span>(b,...) <span class="selector-tag">__SYSCALL_CONCAT</span> (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">__INLINE_SYSCALL_NARGS</span>(...) <span class="selector-tag">__INLINE_SYSCALL_NARGS_X</span> (__VA_ARGS__,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">__INLINE_SYSCALL_NARGS_X</span>(a,b,c,d,e,f,g,h,n,...) <span class="selector-tag">n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上宏展开情况</span></span><br><span class="line"><span class="selector-tag">__SYSCALL_CONCAT</span> (</span><br><span class="line">    __INLINE_SYSCALL,</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    )(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">__SYSCALL_CONCAT</span>(a,b)       <span class="selector-tag">__SYSCALL_CONCAT_X</span> (a, b)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">__SYSCALL_CONCAT_X</span>(a,b)     <span class="selector-tag">a</span>#<span class="selector-id">#b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到</span></span><br><span class="line"><span class="selector-tag">__INLINE_SYSCALL1</span>(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">__INLINE_SYSCALL1</span>(name, a1) <span class="selector-tag">INLINE_SYSCALL</span> (name, <span class="number">1</span>, a1)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">INLINE_SYSCALL</span>(name, nr, args...) <span class="selector-tag">__syscall_</span>#<span class="selector-id">#name</span> (args)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用的内核方法是</span></span><br><span class="line"><span class="selector-tag">__syscall_mmap</span>(__addr, __len, __prot, __flags, __fd, __offset)</span><br></pre></td></tr></table></figure></p>
<p>其中有一些宏在做 <code>##</code> 进行字符拼接的时候 做了两层嵌套，其原因是 在 <code>##</code> 连接的宏定义中 里面的字符不会在进行宏展开了，做一层嵌套的目的是 在前一层先做宏展开 然后在发给下一个宏做 <code>##</code> 以此实现宏展开的需要。<br>最终调用的方法是 <code>__syscall_mmap</code></p>
<p>然后是mmap分配内存的逻辑，先抽离出主要逻辑功能 主要分三个部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *aligned_heap_area;</span><br><span class="line">p2 = MAP_FAILED;</span><br><span class="line"><span class="keyword">if</span> (aligned_heap_area) &#123;</span><br><span class="line">    p2 = (<span class="keyword">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">    <span class="comment">//....#1...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p2 == MAP_FAILED) &#123;</span><br><span class="line">    p1 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">    <span class="keyword">if</span> (p1 != MAP_FAILED) &#123; </span><br><span class="line">        <span class="comment">//...#2...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p2 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        <span class="comment">// ...#3....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在 aligned_heap_area 则按照 aligned_heap_area 作为内存开始地址进行扩展（#1 处代码），否则按照两倍的 HEAP_MAX_SIZE 进行内存的申请（#2 处代码），申请失败的话 再次尝试申请 HEAP_MAX_SIZE 的内存（#3 处代码）。由于mmap 返回的是申请成功的内存的起始位置，这里分配内存 有一个需求是：如果将内存地址(虚拟地址) 按照 HEAP_MAX_SIZE 的长度进行分段 ，new_heap 分配的内存正好在这个段上 起始地址和结束地址都是 HEAP_MAX_SIZE 对齐的 且 长度是 HEAP_MAX_SIZE。<br>当内存申请成功后，这个时候是有申请内存的结尾地址的，将这个地址赋值给 aligned_heap_area 方便下次分配内存的时候 可以直接确定分配内存开始位置 见代码 #1 处，但是在这个过程中内存很有可能被其他线程或进程申请到，这个变量就没有用了 也就是 #1 处的申请内存的代码会失败，<br>这个场景可能比较有限 所以代码 #1 处使用完后立即就将这个变量赋值为NULL了，这个场景可能比较适用连续的大段内存分配吧。</p>
<p>重点是 #2 处的代码，他会尝试分配 两倍 HEAP_MAX_SIZE 的内存，可能会奇怪为什么分配两段。ptmalloc 在通过new_heap 申请内存的时候 他想要申请一段长度为 HEAD_MAX_SIZE 长度的内存，且这段内存的起始内存地址与结束地址是与 HEAD_MAX_SIZE 对齐的，也就是说 分配到的内存地址起始是 <code>n * HEAD_MAX_SIZE</code> 结束地址是 <code>(n+1) * HEAD_MAX_SIZE</code>。<br>对于 mmap 函数 第一个参数是起始地址，一般会给 NULL 让内核决定起始地址，这样内核返回的地址很大情况不会是 HEAD_MAX_SIZE 的倍数，这个时候需要计算返回的内存地址的对齐地址，当然是需要向上对齐，因为前面的内存已经被其他线程占用了。如果我们申请的长度是 HEAD_MAX_SIZE ，如果返回的起始地址不对齐 就要再次申请一段内存补充整个内存长度为 HEAD_MAX_SIZE 但是当再次申请的时候有可能会被其他线程前先一步 这个时候补充的内存段与之前申请的内存段并不连续了，这样就很糟糕。所以ptmallloc在这里一次申请 <code>2 * HEAD_MAX_SIZE</code> 的内存 然后通过<code>__munmap</code>函数将多余的内存返还给系统，通过这个思路来看代码就很好理解了，可以参考下图：<br><img src="WX20190518-230344@2x.png" alt="内存的切割内存"><br>其中 p1 是mmap返回的地址 ，p1 以 HEAD_MAX_SIZE 向上对齐得到 p2 ，p2是我们想要的内存起始地址，同样需要将 p1 开始 长度 p2 - p1 的内存返还给系统，p2 - p1 也就是 ul。<br>同时还有尾部多余的内存需要返还给系统，我们最终需要的内存的结束内存地址是 <code>p2 + HEAP_MAX_SIZE</code> 这也是需要返还给系统的内存起始地址，然后是长度。申请两倍内存的结束地址是 <code>p1 + 2 * HEAP_MAX_SIZE</code> 得到尾部需要返还的内存长度是 <code>(p1 + 2 * HEAP_MAX_SIZE) - (p2 + HEAP_MAX_SIZE)</code> ，结合 <code>p2 - p1 = ul</code> 最终得到 <code>HEAP_MAX_SIZE - ul</code> 这也就是代码中的尾部返还系统内存的长度。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">if (p1 != MAP_FAILED) &#123; // 成功分配两倍HEAP_MAX_SIZE长度的内存 p1 是内存起始地址</span><br><span class="line">    // p2 是 p1 以HEAP_MAX_SIZE向上对齐的地址</span><br><span class="line">    p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1));</span><br><span class="line">    ul = p2 - p1; // p1 需要向上补齐的长度</span><br><span class="line">    // 将头部多余的内存返还给系统</span><br><span class="line">   <span class="built_in"> if </span>(ul) __munmap (p1, ul);</span><br><span class="line">    // 返回的内存地址正好是对齐的 这时给变量aligned_heap_area赋值 给下一个连续的内存申请用 可以直接确定内存起始位置</span><br><span class="line">    else aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">    // 将尾部多余的内存返还给系统</span><br><span class="line">    __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 #3 处的代码，这里的代码好理解，当上一步分配两倍HEAP_MAX_SIZE长度内存的时候失败的话，这里尝试申请HEAP_MAX_SIZE长度内存，看看返回的地址是否为 以HEAP_MAX_SIZE对齐的起始内存地址，这里纯粹是在碰运气的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请 HEAP_MAX_SIZE 长度内存</span></span><br><span class="line">p2 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line"><span class="keyword">if</span> (p2 == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 分配失败 返回</span></span><br><span class="line"><span class="comment">// 分配的内存起始地址 p2 并不是以HEAP_MAX_SIZE对齐的 则返还内存 直接返回</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)) &#123;</span><br><span class="line">    __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-内存的申请过程总结"><a href="#4-内存的申请过程总结" class="headerlink" title="4. 内存的申请过程总结"></a>4. 内存的申请过程总结</h2>
            
                

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/c/">c</a> <a class="tag tag--primary tag--small t-link" href="/tags/glibc/">glibc</a> <a class="tag tag--primary tag--small t-link" href="/tags/malloc/">malloc</a> <a class="tag tag--primary tag--small t-link" href="/tags/ptmalloc/">ptmalloc</a> <a class="tag tag--primary tag--small t-link" href="/tags/内存/">内存</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-int-malloc与chunk合并/"  data-tooltip="malloc源码分析-int_malloc与chunk合并">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-设计思路与基本数据结构/" data-tooltip="malloc源码分析-设计思路与基本数据结构">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            
                <div id="ds-thread" class="ds-thread" data-thread-key="2019/05/13/malloc源码分析-初始化与arena的创建/"
     data-title="malloc源码分析-初始化与arena的创建" data-url="/2019/05/13/malloc源码分析-初始化与arena的创建/">
</div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 fantiq. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-int-malloc与chunk合并/"  data-tooltip="malloc源码分析-int_malloc与chunk合并">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/13/malloc源码分析-设计思路与基本数据结构/" data-tooltip="malloc源码分析-设计思路与基本数据结构">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="3">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-google-plus"></i><span class="">分享到 Google+</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=/2019/05/13/malloc源码分析-初始化与arena的创建/">
                <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg"/>
        
            <h4 id="about-card-name">fantiq</h4>
        
            <h5 id="about-card-bio"><p> good at develop framework </p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>developer</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/scrip-gfmrkxcl0qohe3cfdgxhzvc0yrceqta8i4iix0txvn8q4o2adlqd5n0jmkvt.min.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'fantiq'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



</html>
