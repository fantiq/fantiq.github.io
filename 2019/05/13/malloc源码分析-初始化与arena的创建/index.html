
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="代码狗">
    <title>malloc源码分析-初始化与arena的创建 - 代码狗</title>
    <meta name="author" content="fantiq">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fantiq","sameAs":["https://github.com/fantiq"],"image":"avatar.jpg"},"articleBody":"glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现\n1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias) ASM_LINE_SEP  .set C_SYMBOL_NAME (alias),C_SYMBOL_NAME (original)\n\n1. malloc 整体流程1以下是祛除一些辅助功能后的代码\n1234567891011121314151617181920212223242526272829void * __libc_malloc (size_t bytes) &#123;    mstate ar_ptr;    void *victim;    // 1.1 原子的形式调用钩子方法 __malloc_hook 用以初始化 ptmalloc    void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);    if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0));    // 1.2 获取 或 创建 arena 并且会将arena 加锁(mutex 互斥锁)处理    arena_get (ar_ptr, bytes);    // ptmalloc 核心逻辑    victim = _int_malloc (ar_ptr, bytes);    /* Retry with another arena only if we were able to find a usable arena before.  */    // 如果 ar_ptr 指定的 arena不为空 也就是说 arena_get 获取arena是成功的 但是 _int_malloc 方法返回的 victim 却为空 这里会重新获取一遍arena arena_get_retry    if (!victim &amp;&amp; ar_ptr != NULL) &#123;        LIBC_PROBE (memory_malloc_retry, 1, bytes);        ar_ptr = arena_get_retry (ar_ptr, bytes);        victim = _int_malloc (ar_ptr, bytes);    &#125;    // 解除arena的互斥锁    if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex);    assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim)));    // 返回内存地址给用户    return victim;&#125;\n__libc_malloc 整体流程分如下几步：\n\n通过钩子函数 __malloc_hook 先初始化 ptmalloc 且只会初始化一次\n通过 arena_get 获取当前线程的 arena 如果不存在当前线程的arena则创建一个arena返回 且 这一步还给arena加上互斥锁\n调用核心逻辑 _int_malloc 查询chunk \n如果arena获取成功 上一步却没找到chunk 则通过arena_get_retry 尝试再次分配\n查询成功解锁arena 返回地址给用户\n\n这里需要展开的函数有 __malloc_hook arena_get _int_malloc 其中_int_malloc 作为核心函数 代码量比较大 会放在下一章进行详细分析，这里主要分析 __malloc_hook __malloc_hook\n2.  __malloc_hook 初始化ptmalloc2.1 malloc初始化调用逻辑malloc初始化调用的钩子方法 定义如下：\n1void *weak_variable (*__malloc_hook) (size_t __size, const void *) = malloc_hook_ini;\n这里通过 weak_variable 进行修饰，为了方便用户对这个钩子方法的替换，这个钩子方法指定到了 函数 malloc_hook_ini，源码如下：\n12345678static void * malloc_hook_ini (size_t sz, const void *caller) &#123;    // 清空malloc钩子方法的绑定    __malloc_hook = NULL;    // 调用初始化方法    ptmalloc_init ();    // 从新走 __libc_malloc 方法    return __libc_malloc (sz);&#125;\n当函数执行进来则会将钩子函数的变量设置为 NULL 也是为了保证这个初始化函数只会被调用一次，初始化的主要代码还是在函数 ptmalloc_init ，初始化完毕还是会调用函数 __libc_malloc\n2.2 ptmalloc_init下面是初始化的代码，这里主要为了看逻辑过程 删除了一些配置相关的代码\n1234567891011121314151617181920212223static __thread mstate thread_arena attribute_tls_model_ie;int __malloc_initialized = -1;static void ptmalloc_init (void) &#123;    // 如果执行过或者正在执行中这个方法则直接返回    if (__malloc_initialized &gt;= 0) return;    __malloc_initialized = 0;    #ifdef SHARED        /* In case this libc copy is in a non-default namespace, never use brk. Likewise if dlopened from statically linked program.  */        Dl_info di;        struct link_map *l;        if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) __morecore = __failing_morecore;    #endif    // thread_arena 记录当前线程的arena指针地址 ptmalloc_init 中指定的是主线程的arena    thread_arena = &amp;main_arena;    // 这里对主线程的 arena 进行初始化    malloc_init_state (&amp;main_arena);    // 这里省略了一些配置项设置的代码    // 初始化执行完毕 将变量 __malloc_initialized 赋值为1    __malloc_initialized = 1;&#125;\n结合上面的逻辑可以看出来，初始化的线程一定是主线程，所以这里的当前线程就是 main_arena  thread_arena = &amp;main_arena，然后会通过函数 malloc_init_state 初始化一些值。此方法开始的时候设置 __malloc_initialized=0 结束的时候设置 __malloc_initialized=1 。主要的初始化代码在函数 malloc_init_state需要注意下其中变量 thread_arena 的定义 static __thread mstate thread_arena attribute_tls_model_ie; 变量通过关键词 __thread 进行修饰，也就是说这个全局变量是针对每一个线程的，每一个线程都拥有一个这样的全局变量 且 与其他线程隔离。也就是说 新的线程调用此方法的时候 其 thread_arena 为 NULL 这个会在获取 arena 的函数中用到。\n2.3 malloc_init_state对arena的初始化\n123456789101112131415161718192021222324#define NBINS             128#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4) // 16 * 8 = 128// static void malloc_init_state (mstate av) &#123;    int i;    mbinptr bin;    /* Establish circular links for normal bins */    // 初始化 arena的 bin 列表 bin的作用就是 一个缓冲区 方便查询    for (i = 1; i &lt; NBINS; ++i) &#123;        bin = bin_at (av, i);        bin-&gt;fd = bin-&gt;bk = bin;    &#125;    #if MORECORE_CONTIGUOUS        if (av != &amp;main_arena)    #endif    // 主线程arena 设置 XXX            set_noncontiguous (av);    // 主线程arena设置 fastbin的最大值    if (av == &amp;main_arena) set_max_fast (DEFAULT_MXFAST);    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, false);    av-&gt;top = initial_top (av);&#125;\n函数 malloc_init_state 做的初始化功能主要有 初始化 arena 的 bins、如果是主线程 设置fastbin的最大值 以及 初始化 top先看top的初始化\n12#define initial_top(M)              (unsorted_chunks (M))#define unsorted_chunks(M)          (bin_at (M, 1))\ntop的初始化最终调用的还是 宏 bin_at 不同的是 top 固定了其index为1 所以我们重点关注 宏 bin_at\n1234567#define bin_at(m, i) (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))// 将其简化则如下&amp;bins[(i-1)*2] - 8*2// bins 的定义typedef struct malloc_chunk* mchunkptr;mchunkptr bins[NBINS * 2 - 2];\n从上面的定义关系中其实可以得出 &amp;bins[(i-1)*2] 得出的其实是一个地址 在x64上占8个字节，后面的 - 8*2 相当于在数组上向左移动两个位置 最后我们得到 i 与 实际得到的值的关系是 (i-2)*2 结合代码\n12345for (i = 1; i &lt; NBINS; ++i) &#123;    bin = bin_at(av, i); // 这里指向 的是 bins 数组索引 (i-2)*2    bin-&gt;fd = bin-&gt;bk = bin; // 这里再调用 bin-&gt;fd bin-&gt;bk 其实是在移动上一步得到的地址 通过 malloc_chunk 可以得出 fd 右位移2个位置 bk 右位移3个位置 这个时候就很容易理解为什么bin_at 的宏定义中要 ` - offsetof (struct malloc_chunk, fd)` 了    // 也就是说通过bin_at 得到偏移后的地址 通过 bin-&gt;fb 正好又偏移回来了 也就是说 i = 1 时 idx 0 是bin_at(1)-&gt;fd idx 1 是bin_at(1)-&gt;bk&#125;\n其实最终得到的 bins 的结构如下：\n12345arr idx   0     1    2   3     4    5   ..............   249  250  251  252  253 254        +---------+---------+---------+----------------+---------+---------+---------+        | fd | bk | fd | bk | fd | bk | .............. | fd | bk | fd | bk | fd | bk |        +---------+---------+---------+----------------+---------+---------+---------+         bin_at(1) bin_at(2) bin_at(3)     bin_at(N)   bin_at(125) bin_at(126) bin_at(127) \n这样一个结构 将来是要承载 smallbin largebin unsortedbin 这三种bin链表的，初始化的时候并没有指向到一个malloc_chunk 地址 而是初始化了数组的地址 后面判断 一个bin是否为空链表的时候会用到这个进行判断\n3. arena 的创建arena创建这部分是整个malloc中比较重要的一部分了，在malloc代码通过宏 arena_get 实现，\n123456789101112131415161718#define arena_get(ptr, size) do &#123;    ptr = thread_arena;    arena_lock (ptr, size);&#125; while (0)#define arena_lock(ptr, size)do &#123;    if (ptr) __libc_lock_lock (ptr-&gt;mutex);    else ptr = arena_get2 ((size), NULL);&#125; while (0)// 合并之后的代码ptr = thread_arena;// 如果当前线程arena不为空 则给当前线程加互斥锁if (ptr) __libc_lock_lock (ptr-&gt;mutex);// 当前线程arena为空 说明当前线程是刚刚创建 需要给当前线程创建arenaelse ptr = arena_get2 ((size), NULL);\n\n所以这里代码的重点是 给当前线程创建 arena 也就是调用方法 arena_get2\n3.1 arena_get21234567891011121314151617181920212223242526272829303132static size_t narenas = 1;static mstate arena_get2 (size_t size, mstate avoid_arena) &#123;    mstate a;    static size_t narenas_limit;    // 读取free_list    a = get_free_list ();    if (a == NULL) &#123;        /* Nothing immediately available, so generate a new arena.  */        // 这里是给静态变量 narenas_limit 进行初始化值        if (narenas_limit == 0) &#123;            // arena_max有值则使用arena_max的值            if (mp_.arena_max != 0) narenas_limit = mp_.arena_max;            else if (narenas &gt; mp_.arena_test) &#123;                int n = __get_nprocs (); // 读取CPU核数                if (n &gt;= 1) narenas_limit = NARENAS_FROM_NCORES (n); // ((n) * (sizeof (long) == 4 ? 2 : 8)) -&gt; cpu核数 * [2(x32)|8(x64)]                else /* We have no information about the system.  Assume two cores.  */                    narenas_limit = NARENAS_FROM_NCORES (2);            &#125;        &#125;        repeat:;        size_t n = narenas;        if (__glibc_unlikely (n &lt;= narenas_limit - 1)) &#123;            if (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + 1, n)) goto repeat;            a = _int_new_arena (size);            if (__glibc_unlikely (a == NULL)) catomic_decrement (&amp;narenas);        &#125;        else a = reused_arena (avoid_arena);    &#125;    // 有空闲arena 则直接返回了    return a;&#125;\n这段代码主要有以下几个步骤\n\n通过函数 get_free_list 获取arena 如果获取到则直接返回 获取不到则继续往下进行\n通过内核数量计算出来arena数量最大值 narenas_limit = cpu核数 * 2/8 (x32/x64)\n通过 narenas 与 narenas_limit 确定是通过 _int_new_arena 创建新的 arena 还是 通过 reused_arena 利用现有的arena\n\n接下来要着重分析的是 get_free_list reused_arena _int_new_arena 这三个函数 \n3.2 get_free_list 从free_list查找arena从 free_list 中获取一个合适的 arena，free_list 是指向链表头部的指针，这个链表是由 malloc_state中的属性 next_free 链接的\n1234567891011121314151617181920212223242526272829303132333435363738394041// free_list 是一个malloc_state的指针 用以做成链表typedef struct malloc_state *mstate;static mstate free_list;static mstate get_free_list (void) &#123;    // 当前线程arena    mstate replaced_arena = thread_arena;    mstate result = free_list;    /*读取free_list 这个链表是从 fork调用 时候从父进程copy过来的，如果是在父进程中则free_list 一直为 NULL */    if (result != NULL) &#123;        __libc_lock_lock (free_list_lock);        // 将free_list 指向的malloc_state 从 malloc_state的next_free 组成的链表中取出        result = free_list;        if (result != NULL) &#123;            free_list = result-&gt;next_free;            /* The arena will be attached to this thread.  */            assert (result-&gt;attached_threads == 0);            result-&gt;attached_threads = 1;            detach_arena (replaced_arena); // 将当前线程指向的 malloc_state 中的属性 attached_threads 减一 因为下面要将当前线程换成从 free_list 中获取的arena        &#125;        __libc_lock_unlock (free_list_lock);        if (result != NULL) &#123;            LIBC_PROBE (memory_arena_reuse_free_list, 1, result);            __libc_lock_lock (result-&gt;mutex);            // 取出的arena作为当前线程的arena            thread_arena = result;        &#125;    &#125;    // 若free_list 为 NULL 则直接返回NULL    return result;&#125;// 如果 replaced_arena 不为空 则将其attached_threads 减一static void detach_arena (mstate replaced_arena) &#123;    if (replaced_arena != NULL) &#123;        assert (replaced_arena-&gt;attached_threads &gt; 0);        /* The current implementation only detaches from main_arena in case of allocation failure.          This means that it is likely not beneficial to put the arena on free_list even if the reference count reaches zero.  */        --replaced_arena-&gt;attached_threads;    &#125;&#125;\n问题是 free_list 的数据是从哪里产生的呢，是从系统调用中的 fork 方法产生的，由于linux中线程之间是共享内存的 而进程之间是不共享的，使用 fork创建新的进程的时候 系统会复制一份父进程的内存到子进程中。系统的 fork 方法经过层层调用 最终调用的函数是 __malloc_fork_unlock_child\n1234567891011121314151617181920212223242526272829void __malloc_fork_unlock_child (void)&#123;    // ptmalloc_init 没有调用过 也就是说 ptmalloc没有初始化    if (__malloc_initialized &lt; 1) return;    /* Push all arenas to the free list, except thread_arena, which is attached to the current thread.  */    __libc_lock_init (free_list_lock);    if (thread_arena != NULL) thread_arena-&gt;attached_threads = 1;    // 初始化 free_list 变量    free_list = NULL;    // 从主线程arena开始    for (mstate ar_ptr = &amp;main_arena;; ) &#123;        __libc_lock_init (ar_ptr-&gt;mutex);        /*  free_list 作为一个链表的头指针，通过循环 arean_list 将他们组织到 一个 free_list 指引的链表上            这些arena 都是从父进程中copy过来的 */        if (ar_ptr != thread_arena) &#123;            /* This arena is no longer attached to any thread.  */            ar_ptr-&gt;attached_threads = 0;            // 通过 free_list 将这些arena通过next_free 串联成链表            ar_ptr-&gt;next_free = free_list;            free_list = ar_ptr;        &#125;        // 移动到下一个 arena        ar_ptr = ar_ptr-&gt;next;        // 如果到了主线程arena 说明循环了一圈 结束循环        if (ar_ptr == &amp;main_arena) break;    &#125;    __libc_lock_init (list_lock);&#125;\n\n3.3 reused_arena 重用arena这个方法是从当前进程中的 arena 列表中查询可用的arena 进行接下来的内存分配。其思路是 先通过main_arena 为起点循环遍历 arena 链表，对链表中的arena进行加锁尝试 如果失败则循环到下一个arena 如果成功 将当前线程的arena引用变量 thread_arena替换为当前的arena。替换过程需要做一定的处理 \n\n替换前的thread_arena 的属性 attached_thread需要减一 \n将当前arena从free_list 中移除 将当前arena的attached_thread 加一 \n给 thread_arena赋值并返回 最后还会移动下 next_to_use 方便下次使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static mstate reused_arena (mstate avoid_arena) &#123;    mstate result;    /* FIXME: Access to next_to_use suffers from data races.  */    // 初始化静态变量 next_to_use 为 &amp;main_arena    static mstate next_to_use;    if (next_to_use == NULL) next_to_use = &amp;main_arena;    /* Iterate over all arenas (including those linked from free_list).  */    result = next_to_use;    // 从main_arena开始循环arena链表 直到循环一圈停止查询。在循环过程中 尝试给arena加锁 加锁成功则执行 out 代码片段，另外 __libc_lock_trylock 不会等待锁的 拿不到锁会立刻返回    do &#123;        if (!__libc_lock_trylock (result-&gt;mutex)) goto out;        /* FIXME: This is a data race, see _int_new_arena.  */        result = result-&gt;next;    &#125;while (result != next_to_use);    /* Avoid AVOID_ARENA as we have already failed to allocate memory in that arena and it is currently locked.   */    if (result == avoid_arena) result = result-&gt;next;    /* No arena available without contention.  Wait for the next in line.  */    LIBC_PROBE (memory_arena_reuse_wait, 3, &amp;result-&gt;mutex, result, avoid_arena);    __libc_lock_lock (result-&gt;mutex);    /* Attach the arena to the current thread.  */    out:        &#123;            /* Update the arena thread attachment counters.   */            mstate replaced_arena = thread_arena;            __libc_lock_lock (free_list_lock);            detach_arena (replaced_arena); // 将这个arena的attached_thread 减一 因为thread_arena 需要更换            // 将result从free_list 中去除            remove_from_free_list (result);            // 新的thread_arean 加一            ++result-&gt;attached_threads;            __libc_lock_unlock (free_list_lock);        &#125;    LIBC_PROBE (memory_arena_reuse, 2, result, avoid_arena);    // 替换 thread_arena    thread_arena = result;    // 将 next_to_use 移动到下一个    next_to_use = result-&gt;next;    return result;&#125;static void remove_from_free_list (mstate arena) &#123;    mstate *previous = &amp;free_list;    // 循环 free_list    for (mstate p = free_list; p != NULL; p = p-&gt;next_free) &#123;        assert (p-&gt;attached_threads == 0);        if (p == arena) &#123; // 在free_list 的链表上找到参数 arena            /* Remove the requested arena from the list.  */            *previous = p-&gt;next_free;            break;        &#125;        else previous = &amp;p-&gt;next_free;    &#125;&#125;\n\n3.4 _int_new_arena 新建arena新建一个arena 每个arena都是有若干个 heap 组成的 heap 通过 new_heap 创建，然后就是要设置一些 malloc_state 的参数重要的是 这里创建的 top 后面的内存分配会从top上切割产生，后面有了 bins 的缓存则会从缓存中获取\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static mstate _int_new_arena (size_t size) &#123;    mstate a;    heap_info *h;    char *ptr;    unsigned long misalign;    // 创建 sub_heap 其实 new_heap 是申请内存 这里将 malloc_state top_pad heap_info 和 size 全包含进去 申请内存了    // 多申请 MALLOC_ALIGNMENT 这段内存的目的是 下面对齐的时候需要用到的 怕内存不够    h = new_heap (size + (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT), mp_.top_pad);    if (!h) &#123;        // 创建失败 再次尝试创建 再不成功直接返回        h = new_heap (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT, mp_.top_pad);        if (!h) return 0;    &#125;    // 给heap设置 arena 指针    a = h-&gt;ar_ptr = (mstate) (h + 1);    // 初始化 arena的bins    malloc_init_state (a);    a-&gt;attached_threads = 1;    /*a-&gt;next = NULL;*/    a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;    /* Set up the top chunk, with proper alignment. */    // 新建的arena 初始化arena 初始化top且内存尺寸对齐    // 这里可以看到 当新建一个arena的时候其里面的chunk只有一个top chunk    ptr = (char *) (a + 1);    // misalign 是向下对齐多出来的长度    misalign = (unsigned long) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;    // 先上对齐    if (misalign &gt; 0) ptr += MALLOC_ALIGNMENT - misalign;    // 设置 top chunk    top (a) = (mchunkptr) ptr;    set_head (top (a), (((char *) h + h-&gt;size) - ptr) | PREV_INUSE);    LIBC_PROBE (memory_arena_new, 2, a, size);    // 切换 thread_arena     mstate replaced_arena = thread_arena;    thread_arena = a;        // 当前新的arena 加锁 添加到arena链表     __libc_lock_init (a-&gt;mutex);    __libc_lock_lock (list_lock);    // 添加arena到链表    a-&gt;next = main_arena.next;    atomic_write_barrier ();    main_arena.next = a;    __libc_lock_unlock (list_lock);    __libc_lock_lock (free_list_lock);    detach_arena (replaced_arena);    __libc_lock_unlock (free_list_lock);    // arena增加互斥锁    __libc_lock_lock (a-&gt;mutex);    return a;&#125;\n\n着重看下 在 new_heap 申请完内存后 在函数 _int_new_arena 中对这段内存的划分部分 以及top 部分\n12345678910// h 指向 new_heap 申请到的内存地址起始位置 并且类型是被转成 heap_info 后返回的，这里 h+1 正好是到 h分配完类型 heap_info 成员占用内存后的位置// 且通过类型转换 将后面的内存又划分出了一部分malloc_state 的内存a = h-&gt;ar_ptr = (mstate) (h + 1);ptr = (char *) (a + 1);// 这里是做内存对齐的操作misalign = (unsigned long) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;if (misalign &gt; 0) ptr += MALLOC_ALIGNMENT - misalign;// 开始分配top部分top (a) = (mchunkptr) ptr;set_head (top (a), (((char *) h + h-&gt;size) - ptr) | PREV_INUSE);\n内存划分后的情况如下图所示：对于top部分的处理 宏 进行展开分析\n12345678#define top(ar_ptr) ((ar_ptr)-&gt;top)#define set_head(p, s)       ((p)-&gt;mchunk_size = (s))// 对应代码展开如下ptr = (char *) (a + 1);a-&gt;top = (mchunkptr) ptr; // 确定指针位置// h + size - ptr 这就是剩下的空闲空间的长度a-&gt;top-&gt;mchunk_size = (((char *) h + h-&gt;size) - ptr) | PREV_INUSE; // 设置 top chunk 的 mchunk_size 字段 设置chunk大小 以及 设置 prev_inuse 为已使用(其实这个时候 top chunk 前面并没有 chunk ，设置为已使用是为了后面chunk合并的时候 有一个结束条件)\n\n3.5 new_heap 新建arena 的 sub_heap每个arena 是 由多个行程链表的 heap组成的 称作 sub_heap 吧，其创建的整体逻辑如下注释: \n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static heap_info * new_heap (size_t size, size_t top_pad) &#123;    // 获取系统内存管理的基本尺寸 一般为 4K 这个值可以在 glibc中的全局变量中找到    size_t pagesize = GLRO (dl_pagesize); // 4K    char *p1, *p2;    unsigned long ul;    heap_info *h;    /*    对size进行处理    如果size + top_pad 小于 HEAP_MIN_SIZE 则使用最小值    如果size + top_pad 小于或等于HEAP_MAX_SIZE 则size = size + top_pad    如果size 大于 HEAP_MAX_SIZE 则 return 0     */    if (size + top_pad &lt; HEAP_MIN_SIZE) size = HEAP_MIN_SIZE;    else if (size + top_pad &lt;= HEAP_MAX_SIZE) size += top_pad;    else if (size &gt; HEAP_MAX_SIZE) return 0;    else size = HEAP_MAX_SIZE;    size = ALIGN_UP (size, pagesize); // 4K对齐    p2 = MAP_FAILED;    // 如果上次分配内存计算出了下次内存分配的起始地址 这里合一直接分配了 减少一定的计算量与内核态的切换    if (aligned_heap_area) &#123;        // 直接基于aligned_heap_area作为起始地址分配        p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);        // 清除了        aligned_heap_area = NULL;        // 分配失败 返还申请的内存        if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123;            __munmap (p2, HEAP_MAX_SIZE);            p2 = MAP_FAILED;        &#125;    &#125;    /*    这里通过mmap申请内存，成功会返回申请的内存段的起始地址。且这里想要将内存地址的起始与结束的地址是与 HEAP_MAX_SIZE 对齐的 内存长度是 HEAP_MAX_SIZE。    这里会看到先申请了两倍 HEAP_MAX_SIZE 尺寸的内存，这是怕 当返回的地址不是内存对齐的，这个时候需要向后调整内存地址 使内存起始地址与 HEAP_MAX_SIZE 对齐    这里向后是因为前面的地址可能已经被其他程序申请，然后又要保持内存长度是 HEAP_MAX_SIZE ，这样前面申请的 HEAP_MAX_SIZE 长度内存就不够了，需要再次调用mmap    为了减少调用 这里申请了两倍的内存 然后将多余的通过 __munmap 还回去    */    if (p2 == MAP_FAILED) &#123;        // 申请 两倍 HEAP_MAX_SIZE 长度的内存 p1是内核返回的内存起始地址        p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);        if (p1 != MAP_FAILED) &#123; // 分配成功 对内存尺寸进行调整 使其在 HEAP_MAX_SIZE长度的内存段上            // p1 针对HEAP_MAX_SIZE向上对齐            p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1));            ul = p2 - p1;//由于是向上 所以是 p2 - p1，若 ul = 0 说明 mmap分配的起始地址恰好是HEAP_MAX_SIZE对齐的，不然就需要调整             if (ul) __munmap (p1, ul); // 返还起始地址向上偏移后多出来的地址            else aligned_heap_area = p2 + HEAP_MAX_SIZE;            // 返还由于 两倍HEAP_MAX_SIZE 多出来的部分 只需要 HEAP_MAX_SIZE 长度的内存就好了            __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);        &#125;        else &#123;            /* Try to take the chance that an allocation of only HEAP_MAX_SIZE is already aligned. */            // 两倍内存申请不到，这里只好申请 HEAP_MAX_SIZE 内存 碰碰运气了            p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);            if (p2 == MAP_FAILED) return 0; // 分配失败            // 运气不好 返回的地址 并不能与HEAP_MAX_SIZE对齐 这里只好返回申请的内存 并结束            if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;                __munmap (p2, HEAP_MAX_SIZE);                return 0;            &#125;        &#125;    &#125;    // 设置读写权限    if (__mprotect (p2, size, PROT_READ | PROT_WRITE) != 0) &#123;        __munmap (p2, HEAP_MAX_SIZE);        return 0;    &#125;    // 设置一些heap参数 返回这个申请的heap    h = (heap_info *) p2;    h-&gt;size = size;    h-&gt;mprotect_size = size;    LIBC_PROBE (memory_heap_new, 2, h, h-&gt;size);    return h;&#125;\n先看参数处理部分，相关的宏定义如下：\n123#define HEAP_MIN_SIZE (32 * 1024) // 32K#define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) // x64 上是64M#define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long)) // 4 * [4|8] M\n保持size的大小在 HEAP_MIN_SIZE 与 HEAP_MAX_SIZE 之间\n然后是 size_t pagesize = GLRO (dl_pagesize); 展开宏\n12345678#define GLRO(name) _##name // _dl_pagesize/* Cached value of `getpagesize ()&#x27;.  */EXTERN size_t _dl_pagesize;size_t _dl_pagesize = EXEC_PAGESIZE;#define EXEC_PAGESIZE   4096// 最终的形式是size_t pagesize = EXEC_PAGESIZE;// 4096 byte  也就是 4k\n\n然后是补齐的算法 \n123// 补齐算法 size + size&amp;(base-1)#define ALIGN_UP(base, size)    ALIGN_DOWN ((base) + (size) - 1, (size))#define ALIGN_DOWN(base, size)  ((base) &amp; -((__typeof__ (base)) (size))) // base &amp; -size\n\n这段主要是通过 mmap 申请内存 使用到的一个重要的方法是 mmap 函数原型 void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset) 和 int munmap(void* start, size_t length) ，mmap 分配内存 munmap 释放内存，这些操作都是要切到内核态执行的，|参数|例子|意义||–|–|–||void* start|NULL|内存分配开始的位置 写NULL 这个位置由内核决定||size_t length|[number]|分配内存的长度||int prot|PROT_EXEC:执行 PROT_READ:读 PROT_WRITE:写 PROT_NONE:不可访问|权限||int flags||文件类型 需要与 open 的时候使用的配对儿||int fd|-1|文件句柄 -1 是与匿名搭配使用||off_t offset|0|写入文件的偏移量|这里代码逻辑的设计也是为了减少内核函数的调用，先看其如何通过一系列宏调用系统函数的\n12345678910111213141516171819202122232425#define MMAP_CALL(__nr, __addr, __len, __prot, __flags, __fd, __offset) INLINE_SYSCALL_CALL (__nr, __addr, __len, __prot, __flags, __fd, __offset)#define INLINE_SYSCALL_CALL(...) __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)#define __INLINE_SYSCALL_DISP(b,...) __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)#define __INLINE_SYSCALL_NARGS(...) __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)#define __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n// 以上宏展开情况__SYSCALL_CONCAT (    __INLINE_SYSCALL,    1    )(__VA_ARGS__)#define __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)#define __SYSCALL_CONCAT_X(a,b)     a##b// 得到__INLINE_SYSCALL1(__VA_ARGS__)#define __INLINE_SYSCALL1(name, a1) INLINE_SYSCALL (name, 1, a1)#define INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)// 最终调用的内核方法是__syscall_mmap(__addr, __len, __prot, __flags, __fd, __offset)\n其中有一些宏在做 ## 进行字符拼接的时候 做了两层嵌套，其原因是 在 ## 连接的宏定义中 里面的字符不会在进行宏展开了，做一层嵌套的目的是 在前一层先做宏展开 然后在发给下一个宏做 ## 以此实现宏展开的需要。最终调用的方法是 __syscall_mmap\n然后是mmap分配内存的逻辑，先抽离出主要逻辑功能 主要分三个部分\n12345678910111213141516static char *aligned_heap_area;p2 = MAP_FAILED;if (aligned_heap_area) &#123;    p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);    //....#1...&#125;if (p2 == MAP_FAILED) &#123;    p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);    if (p1 != MAP_FAILED) &#123;         //...#2...    &#125;    else &#123;        p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);        // ...#3....    &#125;&#125;\n如果存在 aligned_heap_area 则按照 aligned_heap_area 作为内存开始地址进行扩展（#1 处代码），否则按照两倍的 HEAP_MAX_SIZE 进行内存的申请（#2 处代码），申请失败的话 再次尝试申请 HEAP_MAX_SIZE 的内存（#3 处代码）。由于mmap 返回的是申请成功的内存的起始位置，这里分配内存 有一个需求是：如果将内存地址(虚拟地址) 按照 HEAP_MAX_SIZE 的长度进行分段 ，new_heap 分配的内存正好在这个段上 起始地址和结束地址都是 HEAP_MAX_SIZE 对齐的 且 长度是 HEAP_MAX_SIZE。当内存申请成功后，这个时候是有申请内存的结尾地址的，将这个地址赋值给 aligned_heap_area 方便下次分配内存的时候 可以直接确定分配内存开始位置 见代码 #1 处，但是在这个过程中内存很有可能被其他线程或进程申请到，这个变量就没有用了 也就是 #1 处的申请内存的代码会失败，这个场景可能比较有限 所以代码 #1 处使用完后立即就将这个变量赋值为NULL了，这个场景可能比较适用连续的大段内存分配吧。\n重点是 #2 处的代码，他会尝试分配 两倍 HEAP_MAX_SIZE 的内存，可能会奇怪为什么分配两段。ptmalloc 在通过new_heap 申请内存的时候 他想要申请一段长度为 HEAD_MAX_SIZE 长度的内存，且这段内存的起始内存地址与结束地址是与 HEAD_MAX_SIZE 对齐的，也就是说 分配到的内存地址起始是 n * HEAD_MAX_SIZE 结束地址是 (n+1) * HEAD_MAX_SIZE。对于 mmap 函数 第一个参数是起始地址，一般会给 NULL 让内核决定起始地址，这样内核返回的地址很大情况不会是 HEAD_MAX_SIZE 的倍数，这个时候需要计算返回的内存地址的对齐地址，当然是需要向上对齐，因为前面的内存已经被其他线程占用了。如果我们申请的长度是 HEAD_MAX_SIZE ，如果返回的起始地址不对齐 就要再次申请一段内存补充整个内存长度为 HEAD_MAX_SIZE 但是当再次申请的时候有可能会被其他线程前先一步 这个时候补充的内存段与之前申请的内存段并不连续了，这样就很糟糕。所以ptmallloc在这里一次申请 2 * HEAD_MAX_SIZE 的内存 然后通过__munmap函数将多余的内存返还给系统，通过这个思路来看代码就很好理解了，可以参考下图：其中 p1 是mmap返回的地址 ，p1 以 HEAD_MAX_SIZE 向上对齐得到 p2 ，p2是我们想要的内存起始地址，同样需要将 p1 开始 长度 p2 - p1 的内存返还给系统，p2 - p1 也就是 ul。同时还有尾部多余的内存需要返还给系统，我们最终需要的内存的结束内存地址是 p2 + HEAP_MAX_SIZE 这也是需要返还给系统的内存起始地址，然后是长度。申请两倍内存的结束地址是 p1 + 2 * HEAP_MAX_SIZE 得到尾部需要返还的内存长度是 (p1 + 2 * HEAP_MAX_SIZE) - (p2 + HEAP_MAX_SIZE) ，结合 p2 - p1 = ul 最终得到 HEAP_MAX_SIZE - ul 这也就是代码中的尾部返还系统内存的长度。\n123456789101112p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);if (p1 != MAP_FAILED) &#123; // 成功分配两倍HEAP_MAX_SIZE长度的内存 p1 是内存起始地址    // p2 是 p1 以HEAP_MAX_SIZE向上对齐的地址    p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1));    ul = p2 - p1; // p1 需要向上补齐的长度    // 将头部多余的内存返还给系统    if (ul) __munmap (p1, ul);    // 返回的内存地址正好是对齐的 这时给变量aligned_heap_area赋值 给下一个连续的内存申请用 可以直接确定内存起始位置    else aligned_heap_area = p2 + HEAP_MAX_SIZE;    // 将尾部多余的内存返还给系统    __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);&#125;\n\n然后是 #3 处的代码，这里的代码好理解，当上一步分配两倍HEAP_MAX_SIZE长度内存的时候失败的话，这里尝试申请HEAP_MAX_SIZE长度内存，看看返回的地址是否为 以HEAP_MAX_SIZE对齐的起始内存地址，这里纯粹是在碰运气的。\n12345678// 申请 HEAP_MAX_SIZE 长度内存p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);if (p2 == MAP_FAILED) return 0; // 分配失败 返回// 分配的内存起始地址 p2 并不是以HEAP_MAX_SIZE对齐的 则返还内存 直接返回if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;    __munmap (p2, HEAP_MAX_SIZE);    return 0;&#125;\n\n\n\n4. 内存的申请过程总结","dateCreated":"2019-05-13T15:16:09+08:00","dateModified":"2019-05-19T11:10:52+08:00","datePublished":"2019-05-13T15:16:09+08:00","description":"glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现\n1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias) ASM_LINE_SEP  .set C_SYMBOL_NAME (alias),C_SYMBOL_NAME (original)","headline":"malloc源码分析-初始化与arena的创建","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"},"publisher":{"@type":"Organization","name":"fantiq","sameAs":["https://github.com/fantiq"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/","keywords":"c, 内存, malloc, glibc, ptmalloc"}</script>
    <meta name="description" content="glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现 1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias)">
<meta property="og:type" content="blog">
<meta property="og:title" content="malloc源码分析-初始化与arena的创建">
<meta property="og:url" content="https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/index.html">
<meta property="og:site_name" content="代码狗">
<meta property="og:description" content="glibc中的malloc方法其实是映射到 __libc_malloc 的，其通过ASM的符号表的形式来实现 1234strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)define strong_alias(original, alias)  .globl C_SYMBOL_NAME (alias)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/WX20190517-150525@2x.png">
<meta property="og:image" content="https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/WX20190518-230344@2x.png">
<meta property="article:published_time" content="2019-05-13T07:16:09.000Z">
<meta property="article:modified_time" content="2019-05-19T03:10:52.107Z">
<meta property="article:author" content="fantiq">
<meta property="article:tag" content="c">
<meta property="article:tag" content="内存">
<meta property="article:tag" content="malloc">
<meta property="article:tag" content="glibc">
<meta property="article:tag" content="ptmalloc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/WX20190517-150525@2x.png">
    
    
        
    
    
        <meta property="og:image" content="https://fantiq.github.io/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-bo1h1ya3kmjmd94f0k5yc43ngmshulfcyc8apgyrr2pfx48g1zk5lyp9do8g.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            代码狗
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">fantiq</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/fantiq"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            malloc源码分析-初始化与arena的创建
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-05-13T15:16:09+08:00">
	
		    5月 13, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%86%85%E5%AD%98/">内存</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>glibc中的malloc方法其实是映射到 <code>__libc_malloc</code> 的，其通过ASM的符号表的形式来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)</span><br><span class="line">define strong_alias(original, alias)</span><br><span class="line">  .globl C_SYMBOL_NAME (alias) ASM_LINE_SEP</span><br><span class="line">  .set C_SYMBOL_NAME (alias),C_SYMBOL_NAME (original)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="1-malloc-整体流程"><a href="#1-malloc-整体流程" class="headerlink" title="1. malloc 整体流程"></a>1. malloc 整体流程</h2><p>1<br>以下是祛除一些辅助功能后的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void * __libc_malloc (size_t bytes) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    void *victim;</span><br><span class="line"></span><br><span class="line">    // 1.1 原子的形式调用钩子方法 __malloc_hook 用以初始化 ptmalloc</span><br><span class="line">    void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);</span><br><span class="line">    if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0));</span><br><span class="line"></span><br><span class="line">    // 1.2 获取 或 创建 arena 并且会将arena 加锁(mutex 互斥锁)处理</span><br><span class="line">    arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">    // ptmalloc 核心逻辑</span><br><span class="line">    victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    /* Retry with another arena only if we were able to find a usable arena before.  */</span><br><span class="line"></span><br><span class="line">    // 如果 ar_ptr 指定的 arena不为空 也就是说 arena_get 获取arena是成功的 但是 _int_malloc 方法返回的 victim 却为空 这里会重新获取一遍arena arena_get_retry</span><br><span class="line">    if (!victim &amp;&amp; ar_ptr != NULL) &#123;</span><br><span class="line">        LIBC_PROBE (memory_malloc_retry, 1, bytes);</span><br><span class="line">        ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">        victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解除arena的互斥锁</span><br><span class="line">    if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">    // 返回内存地址给用户</span><br><span class="line">    return victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__libc_malloc</code> 整体流程分如下几步：</p>
<ol>
<li>通过钩子函数 <code>__malloc_hook</code> 先初始化 <code>ptmalloc</code> 且只会初始化一次</li>
<li>通过 arena_get 获取当前线程的 arena 如果不存在当前线程的arena则创建一个arena返回 且 这一步还给arena加上互斥锁</li>
<li>调用核心逻辑 _int_malloc 查询chunk </li>
<li>如果arena获取成功 上一步却没找到chunk 则通过arena_get_retry 尝试再次分配</li>
<li>查询成功解锁arena 返回地址给用户</li>
</ol>
<p>这里需要展开的函数有 <code>__malloc_hook</code> <code>arena_get</code> <code>_int_malloc</code> 其中<code>_int_malloc</code> 作为核心函数 代码量比较大 会放在下一章进行详细分析，这里主要分析 <code>__malloc_hook</code> <code>__malloc_hook</code></p>
<h2 id="2-malloc-hook-初始化ptmalloc"><a href="#2-malloc-hook-初始化ptmalloc" class="headerlink" title="2.  __malloc_hook 初始化ptmalloc"></a>2. <code> __malloc_hook</code> 初始化ptmalloc</h2><h4 id="2-1-malloc初始化调用逻辑"><a href="#2-1-malloc初始化调用逻辑" class="headerlink" title="2.1 malloc初始化调用逻辑"></a>2.1 malloc初始化调用逻辑</h4><p>malloc初始化调用的钩子方法 定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *weak_variable (*__malloc_hook) (size_t __size, const void *) = malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>weak_variable</code> 进行修饰，为了方便用户对这个钩子方法的替换，这个钩子方法指定到了 函数 malloc_hook_ini，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void * malloc_hook_ini (size_t sz, const void *caller) &#123;</span><br><span class="line">    // 清空malloc钩子方法的绑定</span><br><span class="line">    __malloc_hook = NULL;</span><br><span class="line">    // 调用初始化方法</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">    // 从新走 __libc_malloc 方法</span><br><span class="line">    return __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数执行进来则会将钩子函数的变量设置为 NULL 也是为了保证这个初始化函数只会被调用一次，初始化的主要代码还是在函数 <code>ptmalloc_init</code> ，初始化完毕还是会调用函数 <code>__libc_malloc</code></p>
<h4 id="2-2-ptmalloc-init"><a href="#2-2-ptmalloc-init" class="headerlink" title="2.2 ptmalloc_init"></a>2.2 ptmalloc_init</h4><p>下面是初始化的代码，这里主要为了看逻辑过程 删除了一些配置相关的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static __thread mstate thread_arena attribute_tls_model_ie;</span><br><span class="line">int __malloc_initialized = -1;</span><br><span class="line">static void ptmalloc_init (void) &#123;</span><br><span class="line">    // 如果执行过或者正在执行中这个方法则直接返回</span><br><span class="line">    if (__malloc_initialized &gt;= 0) return;</span><br><span class="line">    __malloc_initialized = 0;</span><br><span class="line"></span><br><span class="line">    #ifdef SHARED</span><br><span class="line">        /* In case this libc copy is in a non-default namespace, never use brk. Likewise if dlopened from statically linked program.  */</span><br><span class="line">        Dl_info di;</span><br><span class="line">        struct link_map *l;</span><br><span class="line">        if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) __morecore = __failing_morecore;</span><br><span class="line">    #endif</span><br><span class="line">    // thread_arena 记录当前线程的arena指针地址 ptmalloc_init 中指定的是主线程的arena</span><br><span class="line">    thread_arena = &amp;main_arena;</span><br><span class="line">    // 这里对主线程的 arena 进行初始化</span><br><span class="line">    malloc_init_state (&amp;main_arena);</span><br><span class="line"></span><br><span class="line">    // 这里省略了一些配置项设置的代码</span><br><span class="line"></span><br><span class="line">    // 初始化执行完毕 将变量 __malloc_initialized 赋值为1</span><br><span class="line">    __malloc_initialized = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面的逻辑可以看出来，初始化的线程一定是主线程，所以这里的当前线程就是 main_arena  <code>thread_arena = &amp;main_arena</code>，然后会通过函数 <code>malloc_init_state</code> 初始化一些值。<br>此方法开始的时候设置 <code>__malloc_initialized=0</code> 结束的时候设置 <code>__malloc_initialized=1</code> 。主要的初始化代码在函数 <code>malloc_init_state</code><br>需要注意下其中变量 thread_arena 的定义 <code>static __thread mstate thread_arena attribute_tls_model_ie;</code> 变量通过关键词 <code>__thread</code> 进行修饰，也就是说这个全局变量是针对每一个线程的，每一个线程都拥有一个这样的全局变量 且 与其他线程隔离。<br>也就是说 新的线程调用此方法的时候 其 thread_arena 为 NULL 这个会在获取 arena 的函数中用到。</p>
<h4 id="2-3-malloc-init-state"><a href="#2-3-malloc-init-state" class="headerlink" title="2.3 malloc_init_state"></a>2.3 malloc_init_state</h4><p>对arena的初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define NBINS             128</span><br><span class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4) // 16 * 8 = 128</span><br><span class="line">// </span><br><span class="line">static void malloc_init_state (mstate av) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line"></span><br><span class="line">    /* Establish circular links for normal bins */</span><br><span class="line">    // 初始化 arena的 bin 列表 bin的作用就是 一个缓冲区 方便查询</span><br><span class="line">    for (i = 1; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at (av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #if MORECORE_CONTIGUOUS</span><br><span class="line">        if (av != &amp;main_arena)</span><br><span class="line">    #endif</span><br><span class="line">    // 主线程arena 设置 XXX</span><br><span class="line">            set_noncontiguous (av);</span><br><span class="line">    // 主线程arena设置 fastbin的最大值</span><br><span class="line">    if (av == &amp;main_arena) set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, false);</span><br><span class="line">    av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>malloc_init_state</code> 做的初始化功能主要有 初始化 arena 的 bins、如果是主线程 设置fastbin的最大值 以及 初始化 top<br>先看top的初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define initial_top(M)              (unsorted_chunks (M))</span><br><span class="line">#define unsorted_chunks(M)          (bin_at (M, 1))</span><br></pre></td></tr></table></figure>
<p>top的初始化最终调用的还是 宏 <code>bin_at</code> 不同的是 top 固定了其index为1 所以我们重点关注 宏 <code>bin_at</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define bin_at(m, i) (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))</span><br><span class="line">// 将其简化则如下</span><br><span class="line">&amp;bins[(i-1)*2] - 8*2</span><br><span class="line"></span><br><span class="line">// bins 的定义</span><br><span class="line">typedef struct malloc_chunk* mchunkptr;</span><br><span class="line">mchunkptr bins[NBINS * 2 - 2];</span><br></pre></td></tr></table></figure>
<p>从上面的定义关系中其实可以得出 <code>&amp;bins[(i-1)*2]</code> 得出的其实是一个地址 在x64上占8个字节，后面的 <code>- 8*2</code> 相当于在数组上向左移动两个位置 最后我们得到 i 与 实际得到的值的关系是 <code>(i-2)*2</code> 结合代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt; NBINS; ++i) &#123;</span><br><span class="line">    bin = bin_at(av, i); // 这里指向 的是 bins 数组索引 (i-2)*2</span><br><span class="line">    bin-&gt;fd = bin-&gt;bk = bin; // 这里再调用 bin-&gt;fd bin-&gt;bk 其实是在移动上一步得到的地址 通过 malloc_chunk 可以得出 fd 右位移2个位置 bk 右位移3个位置 这个时候就很容易理解为什么bin_at 的宏定义中要 ` - offsetof (struct malloc_chunk, fd)` 了</span><br><span class="line">    // 也就是说通过bin_at 得到偏移后的地址 通过 bin-&gt;fb 正好又偏移回来了 也就是说 i = 1 时 idx 0 是bin_at(1)-&gt;fd idx 1 是bin_at(1)-&gt;bk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最终得到的 bins 的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr idx   0     1    2   3     4    5   ..............   249  250  251  252  253 254</span><br><span class="line">        +---------+---------+---------+----------------+---------+---------+---------+</span><br><span class="line">        | fd | bk | fd | bk | fd | bk | .............. | fd | bk | fd | bk | fd | bk |</span><br><span class="line">        +---------+---------+---------+----------------+---------+---------+---------+</span><br><span class="line">         bin_at(1) bin_at(2) bin_at(3)     bin_at(N)   bin_at(125) bin_at(126) bin_at(127) </span><br></pre></td></tr></table></figure>
<p>这样一个结构 将来是要承载 smallbin largebin unsortedbin 这三种bin链表的，初始化的时候并没有指向到一个malloc_chunk 地址 而是初始化了数组的地址 后面判断 一个bin是否为空链表的时候会用到这个进行判断</p>
<h2 id="3-arena-的创建"><a href="#3-arena-的创建" class="headerlink" title="3. arena 的创建"></a>3. arena 的创建</h2><p>arena创建这部分是整个malloc中比较重要的一部分了，在malloc代码通过宏 <code>arena_get</code> 实现，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define arena_get(ptr, size) </span><br><span class="line">do &#123;</span><br><span class="line">    ptr = thread_arena;</span><br><span class="line">    arena_lock (ptr, size);</span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br><span class="line">#define arena_lock(ptr, size)</span><br><span class="line">do &#123;</span><br><span class="line">    if (ptr) __libc_lock_lock (ptr-&gt;mutex);</span><br><span class="line">    else ptr = arena_get2 ((size), NULL);</span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br><span class="line">// 合并之后的代码</span><br><span class="line">ptr = thread_arena;</span><br><span class="line">// 如果当前线程arena不为空 则给当前线程加互斥锁</span><br><span class="line">if (ptr) __libc_lock_lock (ptr-&gt;mutex);</span><br><span class="line">// 当前线程arena为空 说明当前线程是刚刚创建 需要给当前线程创建arena</span><br><span class="line">else ptr = arena_get2 ((size), NULL);</span><br></pre></td></tr></table></figure>

<p>所以这里代码的重点是 给当前线程创建 arena 也就是调用方法 <code>arena_get2</code></p>
<h4 id="3-1-arena-get2"><a href="#3-1-arena-get2" class="headerlink" title="3.1 arena_get2"></a>3.1 arena_get2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static size_t narenas = 1;</span><br><span class="line"></span><br><span class="line">static mstate arena_get2 (size_t size, mstate avoid_arena) &#123;</span><br><span class="line">    mstate a;</span><br><span class="line">    static size_t narenas_limit;</span><br><span class="line">    // 读取free_list</span><br><span class="line">    a = get_free_list ();</span><br><span class="line">    if (a == NULL) &#123;</span><br><span class="line">        /* Nothing immediately available, so generate a new arena.  */</span><br><span class="line">        // 这里是给静态变量 narenas_limit 进行初始化值</span><br><span class="line">        if (narenas_limit == 0) &#123;</span><br><span class="line">            // arena_max有值则使用arena_max的值</span><br><span class="line">            if (mp_.arena_max != 0) narenas_limit = mp_.arena_max;</span><br><span class="line">            else if (narenas &gt; mp_.arena_test) &#123;</span><br><span class="line">                int n = __get_nprocs (); // 读取CPU核数</span><br><span class="line">                if (n &gt;= 1) narenas_limit = NARENAS_FROM_NCORES (n); // ((n) * (sizeof (long) == 4 ? 2 : 8)) -&gt; cpu核数 * [2(x32)|8(x64)]</span><br><span class="line">                else /* We have no information about the system.  Assume two cores.  */</span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES (2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        repeat:;</span><br><span class="line">        size_t n = narenas;</span><br><span class="line">        if (__glibc_unlikely (n &lt;= narenas_limit - 1)) &#123;</span><br><span class="line">            if (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + 1, n)) goto repeat;</span><br><span class="line">            a = _int_new_arena (size);</span><br><span class="line">            if (__glibc_unlikely (a == NULL)) catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">        else a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">    // 有空闲arena 则直接返回了</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要有以下几个步骤</p>
<ol>
<li>通过函数 get_free_list 获取arena 如果获取到则直接返回 获取不到则继续往下进行</li>
<li>通过内核数量计算出来arena数量最大值 narenas_limit = cpu核数 * 2/8 (x32/x64)</li>
<li>通过 narenas 与 narenas_limit 确定是通过 <code>_int_new_arena</code> 创建新的 arena 还是 通过 reused_arena 利用现有的arena</li>
</ol>
<p>接下来要着重分析的是 <code>get_free_list</code> <code>reused_arena</code> <code>_int_new_arena</code> 这三个函数 </p>
<h4 id="3-2-get-free-list-从free-list查找arena"><a href="#3-2-get-free-list-从free-list查找arena" class="headerlink" title="3.2 get_free_list 从free_list查找arena"></a>3.2 get_free_list 从free_list查找arena</h4><p>从 free_list 中获取一个合适的 arena，free_list 是指向链表头部的指针，这个链表是由 malloc_state中的属性 <code>next_free</code> 链接的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// free_list 是一个malloc_state的指针 用以做成链表</span><br><span class="line">typedef struct malloc_state *mstate;</span><br><span class="line">static mstate free_list;</span><br><span class="line"></span><br><span class="line">static mstate get_free_list (void) &#123;</span><br><span class="line">    // 当前线程arena</span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    mstate result = free_list;</span><br><span class="line">    /*读取free_list 这个链表是从 fork调用 时候从父进程copy过来的，如果是在父进程中则free_list 一直为 NULL */</span><br><span class="line">    if (result != NULL) &#123;</span><br><span class="line">        __libc_lock_lock (free_list_lock);</span><br><span class="line">        // 将free_list 指向的malloc_state 从 malloc_state的next_free 组成的链表中取出</span><br><span class="line">        result = free_list;</span><br><span class="line">        if (result != NULL) &#123;</span><br><span class="line">            free_list = result-&gt;next_free;</span><br><span class="line">            /* The arena will be attached to this thread.  */</span><br><span class="line">            assert (result-&gt;attached_threads == 0);</span><br><span class="line">            result-&gt;attached_threads = 1;</span><br><span class="line">            detach_arena (replaced_arena); // 将当前线程指向的 malloc_state 中的属性 attached_threads 减一 因为下面要将当前线程换成从 free_list 中获取的arena</span><br><span class="line">        &#125;</span><br><span class="line">        __libc_lock_unlock (free_list_lock);</span><br><span class="line"></span><br><span class="line">        if (result != NULL) &#123;</span><br><span class="line">            LIBC_PROBE (memory_arena_reuse_free_list, 1, result);</span><br><span class="line">            __libc_lock_lock (result-&gt;mutex);</span><br><span class="line">            // 取出的arena作为当前线程的arena</span><br><span class="line">            thread_arena = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若free_list 为 NULL 则直接返回NULL</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">// 如果 replaced_arena 不为空 则将其attached_threads 减一</span><br><span class="line">static void detach_arena (mstate replaced_arena) &#123;</span><br><span class="line">    if (replaced_arena != NULL) &#123;</span><br><span class="line">        assert (replaced_arena-&gt;attached_threads &gt; 0);</span><br><span class="line">        /* The current implementation only detaches from main_arena in case of allocation failure.  </span><br><span class="line">        This means that it is likely not beneficial to put the arena on free_list even if the reference count reaches zero.  */</span><br><span class="line">        --replaced_arena-&gt;attached_threads;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是 free_list 的数据是从哪里产生的呢，是从系统调用中的 <code>fork</code> 方法产生的，由于linux中线程之间是共享内存的 而进程之间是不共享的，使用 <code>fork</code>创建新的进程的时候 系统会复制一份父进程的内存到子进程中。系统的 <code>fork</code> 方法经过层层调用 最终调用的函数是 <code>__malloc_fork_unlock_child</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void __malloc_fork_unlock_child (void)</span><br><span class="line">&#123;</span><br><span class="line">    // ptmalloc_init 没有调用过 也就是说 ptmalloc没有初始化</span><br><span class="line">    if (__malloc_initialized &lt; 1) return;</span><br><span class="line">    /* Push all arenas to the free list, except thread_arena, which is attached to the current thread.  */</span><br><span class="line">    __libc_lock_init (free_list_lock);</span><br><span class="line">    if (thread_arena != NULL) thread_arena-&gt;attached_threads = 1;</span><br><span class="line">    // 初始化 free_list 变量</span><br><span class="line">    free_list = NULL;</span><br><span class="line">    // 从主线程arena开始</span><br><span class="line">    for (mstate ar_ptr = &amp;main_arena;; ) &#123;</span><br><span class="line">        __libc_lock_init (ar_ptr-&gt;mutex);</span><br><span class="line">        /*  free_list 作为一个链表的头指针，通过循环 arean_list 将他们组织到 一个 free_list 指引的链表上</span><br><span class="line">            这些arena 都是从父进程中copy过来的 */</span><br><span class="line">        if (ar_ptr != thread_arena) &#123;</span><br><span class="line">            /* This arena is no longer attached to any thread.  */</span><br><span class="line">            ar_ptr-&gt;attached_threads = 0;</span><br><span class="line">            // 通过 free_list 将这些arena通过next_free 串联成链表</span><br><span class="line">            ar_ptr-&gt;next_free = free_list;</span><br><span class="line">            free_list = ar_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        // 移动到下一个 arena</span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        // 如果到了主线程arena 说明循环了一圈 结束循环</span><br><span class="line">        if (ar_ptr == &amp;main_arena) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __libc_lock_init (list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-reused-arena-重用arena"><a href="#3-3-reused-arena-重用arena" class="headerlink" title="3.3 reused_arena 重用arena"></a>3.3 reused_arena 重用arena</h4><p>这个方法是从当前进程中的 arena 列表中查询可用的arena 进行接下来的内存分配。其思路是 先通过main_arena 为起点循环遍历 arena 链表，对链表中的arena进行加锁尝试 如果失败则循环到下一个arena 如果成功 将当前线程的arena引用变量 thread_arena替换为当前的arena。<br>替换过程需要做一定的处理 </p>
<ol>
<li>替换前的thread_arena 的属性 attached_thread需要减一 </li>
<li>将当前arena从free_list 中移除 将当前arena的attached_thread 加一 </li>
<li>给 thread_arena赋值并返回 最后还会移动下 next_to_use 方便下次使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static mstate reused_arena (mstate avoid_arena) &#123;</span><br><span class="line">    mstate result;</span><br><span class="line">    /* FIXME: Access to next_to_use suffers from data races.  */</span><br><span class="line">    // 初始化静态变量 next_to_use 为 &amp;main_arena</span><br><span class="line">    static mstate next_to_use;</span><br><span class="line">    if (next_to_use == NULL) next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">    /* Iterate over all arenas (including those linked from free_list).  */</span><br><span class="line">    result = next_to_use;</span><br><span class="line">    // 从main_arena开始循环arena链表 直到循环一圈停止查询。在循环过程中 尝试给arena加锁 加锁成功则执行 out 代码片段，另外 __libc_lock_trylock 不会等待锁的 拿不到锁会立刻返回</span><br><span class="line">    do &#123;</span><br><span class="line">        if (!__libc_lock_trylock (result-&gt;mutex)) goto out;</span><br><span class="line">        /* FIXME: This is a data race, see _int_new_arena.  */</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125;while (result != next_to_use);</span><br><span class="line"></span><br><span class="line">    /* Avoid AVOID_ARENA as we have already failed to allocate memory in that arena and it is currently locked.   */</span><br><span class="line">    if (result == avoid_arena) result = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    /* No arena available without contention.  Wait for the next in line.  */</span><br><span class="line">    LIBC_PROBE (memory_arena_reuse_wait, 3, &amp;result-&gt;mutex, result, avoid_arena);</span><br><span class="line">    __libc_lock_lock (result-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    /* Attach the arena to the current thread.  */</span><br><span class="line">    out:</span><br><span class="line">        &#123;</span><br><span class="line">            /* Update the arena thread attachment counters.   */</span><br><span class="line">            mstate replaced_arena = thread_arena;</span><br><span class="line">            __libc_lock_lock (free_list_lock);</span><br><span class="line">            detach_arena (replaced_arena); // 将这个arena的attached_thread 减一 因为thread_arena 需要更换</span><br><span class="line">            // 将result从free_list 中去除</span><br><span class="line">            remove_from_free_list (result);</span><br><span class="line">            // 新的thread_arean 加一</span><br><span class="line">            ++result-&gt;attached_threads;</span><br><span class="line">            __libc_lock_unlock (free_list_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    LIBC_PROBE (memory_arena_reuse, 2, result, avoid_arena);</span><br><span class="line">    // 替换 thread_arena</span><br><span class="line">    thread_arena = result;</span><br><span class="line">    // 将 next_to_use 移动到下一个</span><br><span class="line">    next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void remove_from_free_list (mstate arena) &#123;</span><br><span class="line">    mstate *previous = &amp;free_list;</span><br><span class="line">    // 循环 free_list</span><br><span class="line">    for (mstate p = free_list; p != NULL; p = p-&gt;next_free) &#123;</span><br><span class="line">        assert (p-&gt;attached_threads == 0);</span><br><span class="line">        if (p == arena) &#123; // 在free_list 的链表上找到参数 arena</span><br><span class="line">            /* Remove the requested arena from the list.  */</span><br><span class="line">            *previous = p-&gt;next_free;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else previous = &amp;p-&gt;next_free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-4-int-new-arena-新建arena"><a href="#3-4-int-new-arena-新建arena" class="headerlink" title="3.4 _int_new_arena 新建arena"></a>3.4 <code>_int_new_arena</code> 新建arena</h4><p>新建一个arena 每个arena都是有若干个 heap 组成的 heap 通过 <code>new_heap</code> 创建，然后就是要设置一些 malloc_state 的参数<br>重要的是 这里创建的 top 后面的内存分配会从top上切割产生，后面有了 bins 的缓存则会从缓存中获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static mstate _int_new_arena (size_t size) &#123;</span><br><span class="line">    mstate a;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    char *ptr;</span><br><span class="line">    unsigned long misalign;</span><br><span class="line">    // 创建 sub_heap 其实 new_heap 是申请内存 这里将 malloc_state top_pad heap_info 和 size 全包含进去 申请内存了</span><br><span class="line">    // 多申请 MALLOC_ALIGNMENT 这段内存的目的是 下面对齐的时候需要用到的 怕内存不够</span><br><span class="line">    h = new_heap (size + (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br><span class="line">    if (!h) &#123;</span><br><span class="line">        // 创建失败 再次尝试创建 再不成功直接返回</span><br><span class="line">        h = new_heap (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">        if (!h) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 给heap设置 arena 指针</span><br><span class="line">    a = h-&gt;ar_ptr = (mstate) (h + 1);</span><br><span class="line">    // 初始化 arena的bins</span><br><span class="line">    malloc_init_state (a);</span><br><span class="line">    a-&gt;attached_threads = 1;</span><br><span class="line">    /*a-&gt;next = NULL;*/</span><br><span class="line">    a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line"></span><br><span class="line">    /* Set up the top chunk, with proper alignment. */</span><br><span class="line">    // 新建的arena 初始化arena 初始化top且内存尺寸对齐</span><br><span class="line">    // 这里可以看到 当新建一个arena的时候其里面的chunk只有一个top chunk</span><br><span class="line">    ptr = (char *) (a + 1);</span><br><span class="line">    // misalign 是向下对齐多出来的长度</span><br><span class="line">    misalign = (unsigned long) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">    // 先上对齐</span><br><span class="line">    if (misalign &gt; 0) ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">    // 设置 top chunk</span><br><span class="line">    top (a) = (mchunkptr) ptr;</span><br><span class="line">    set_head (top (a), (((char *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    LIBC_PROBE (memory_arena_new, 2, a, size);</span><br><span class="line">    // 切换 thread_arena </span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    thread_arena = a;</span><br><span class="line">    </span><br><span class="line">    // 当前新的arena 加锁 添加到arena链表 </span><br><span class="line">    __libc_lock_init (a-&gt;mutex);</span><br><span class="line">    __libc_lock_lock (list_lock);</span><br><span class="line">    // 添加arena到链表</span><br><span class="line">    a-&gt;next = main_arena.next;</span><br><span class="line">    atomic_write_barrier ();</span><br><span class="line">    main_arena.next = a;</span><br><span class="line">    __libc_lock_unlock (list_lock);</span><br><span class="line">    __libc_lock_lock (free_list_lock);</span><br><span class="line">    detach_arena (replaced_arena);</span><br><span class="line">    __libc_lock_unlock (free_list_lock);</span><br><span class="line">    // arena增加互斥锁</span><br><span class="line">    __libc_lock_lock (a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>着重看下 在 <code>new_heap</code> 申请完内存后 在函数 <code>_int_new_arena</code> 中对这段内存的划分部分 以及top 部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// h 指向 new_heap 申请到的内存地址起始位置 并且类型是被转成 heap_info 后返回的，这里 h+1 正好是到 h分配完类型 heap_info 成员占用内存后的位置</span><br><span class="line">// 且通过类型转换 将后面的内存又划分出了一部分malloc_state 的内存</span><br><span class="line">a = h-&gt;ar_ptr = (mstate) (h + 1);</span><br><span class="line">ptr = (char *) (a + 1);</span><br><span class="line">// 这里是做内存对齐的操作</span><br><span class="line">misalign = (unsigned long) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">if (misalign &gt; 0) ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">// 开始分配top部分</span><br><span class="line">top (a) = (mchunkptr) ptr;</span><br><span class="line">set_head (top (a), (((char *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br></pre></td></tr></table></figure>
<p>内存划分后的情况如下图所示：<br><img src="WX20190517-150525@2x.png" alt="内存分配情况"><br>对于top部分的处理 宏 进行展开分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define top(ar_ptr) ((ar_ptr)-&gt;top)</span><br><span class="line">#define set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="line"></span><br><span class="line">// 对应代码展开如下</span><br><span class="line">ptr = (char *) (a + 1);</span><br><span class="line">a-&gt;top = (mchunkptr) ptr; // 确定指针位置</span><br><span class="line">// h + size - ptr 这就是剩下的空闲空间的长度</span><br><span class="line">a-&gt;top-&gt;mchunk_size = (((char *) h + h-&gt;size) - ptr) | PREV_INUSE; // 设置 top chunk 的 mchunk_size 字段 设置chunk大小 以及 设置 prev_inuse 为已使用(其实这个时候 top chunk 前面并没有 chunk ，设置为已使用是为了后面chunk合并的时候 有一个结束条件)</span><br></pre></td></tr></table></figure>

<h4 id="3-5-new-heap-新建arena-的-sub-heap"><a href="#3-5-new-heap-新建arena-的-sub-heap" class="headerlink" title="3.5 new_heap 新建arena 的 sub_heap"></a>3.5 <code>new_heap</code> 新建arena 的 sub_heap</h4><p>每个arena 是 由多个行程链表的 heap组成的 称作 sub_heap 吧，其创建的整体逻辑如下注释: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">static heap_info * new_heap (size_t size, size_t top_pad) &#123;</span><br><span class="line">    // 获取系统内存管理的基本尺寸 一般为 4K 这个值可以在 glibc中的全局变量中找到</span><br><span class="line">    size_t pagesize = GLRO (dl_pagesize); // 4K</span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    unsigned long ul;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    /*</span><br><span class="line">    对size进行处理</span><br><span class="line">    如果size + top_pad 小于 HEAP_MIN_SIZE 则使用最小值</span><br><span class="line">    如果size + top_pad 小于或等于HEAP_MAX_SIZE 则size = size + top_pad</span><br><span class="line">    如果size 大于 HEAP_MAX_SIZE 则 return 0 </span><br><span class="line">    */</span><br><span class="line">    if (size + top_pad &lt; HEAP_MIN_SIZE) size = HEAP_MIN_SIZE;</span><br><span class="line">    else if (size + top_pad &lt;= HEAP_MAX_SIZE) size += top_pad;</span><br><span class="line">    else if (size &gt; HEAP_MAX_SIZE) return 0;</span><br><span class="line">    else size = HEAP_MAX_SIZE;</span><br><span class="line">    size = ALIGN_UP (size, pagesize); // 4K对齐</span><br><span class="line"></span><br><span class="line">    p2 = MAP_FAILED;</span><br><span class="line">    // 如果上次分配内存计算出了下次内存分配的起始地址 这里合一直接分配了 减少一定的计算量与内核态的切换</span><br><span class="line">    if (aligned_heap_area) &#123;</span><br><span class="line">        // 直接基于aligned_heap_area作为起始地址分配</span><br><span class="line">        p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        // 清除了</span><br><span class="line">        aligned_heap_area = NULL;</span><br><span class="line">        // 分配失败 返还申请的内存</span><br><span class="line">        if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123;</span><br><span class="line">            __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">            p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    这里通过mmap申请内存，成功会返回申请的内存段的起始地址。且这里想要将内存地址的起始与结束的地址是与 HEAP_MAX_SIZE 对齐的 内存长度是 HEAP_MAX_SIZE。</span><br><span class="line">    这里会看到先申请了两倍 HEAP_MAX_SIZE 尺寸的内存，这是怕 当返回的地址不是内存对齐的，这个时候需要向后调整内存地址 使内存起始地址与 HEAP_MAX_SIZE 对齐</span><br><span class="line">    这里向后是因为前面的地址可能已经被其他程序申请，然后又要保持内存长度是 HEAP_MAX_SIZE ，这样前面申请的 HEAP_MAX_SIZE 长度内存就不够了，需要再次调用mmap</span><br><span class="line">    为了减少调用 这里申请了两倍的内存 然后将多余的通过 __munmap 还回去</span><br><span class="line">    */</span><br><span class="line">    if (p2 == MAP_FAILED) &#123;</span><br><span class="line">        // 申请 两倍 HEAP_MAX_SIZE 长度的内存 p1是内核返回的内存起始地址</span><br><span class="line">        p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        if (p1 != MAP_FAILED) &#123; // 分配成功 对内存尺寸进行调整 使其在 HEAP_MAX_SIZE长度的内存段上</span><br><span class="line">            // p1 针对HEAP_MAX_SIZE向上对齐</span><br><span class="line">            p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1));</span><br><span class="line">            ul = p2 - p1;//由于是向上 所以是 p2 - p1，若 ul = 0 说明 mmap分配的起始地址恰好是HEAP_MAX_SIZE对齐的，不然就需要调整 </span><br><span class="line">            if (ul) __munmap (p1, ul); // 返还起始地址向上偏移后多出来的地址</span><br><span class="line">            else aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">            // 返还由于 两倍HEAP_MAX_SIZE 多出来的部分 只需要 HEAP_MAX_SIZE 长度的内存就好了</span><br><span class="line">            __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            /* Try to take the chance that an allocation of only HEAP_MAX_SIZE is already aligned. */</span><br><span class="line">            // 两倍内存申请不到，这里只好申请 HEAP_MAX_SIZE 内存 碰碰运气了</span><br><span class="line">            p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">            if (p2 == MAP_FAILED) return 0; // 分配失败</span><br><span class="line">            // 运气不好 返回的地址 并不能与HEAP_MAX_SIZE对齐 这里只好返回申请的内存 并结束</span><br><span class="line">            if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;</span><br><span class="line">                __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置读写权限</span><br><span class="line">    if (__mprotect (p2, size, PROT_READ | PROT_WRITE) != 0) &#123;</span><br><span class="line">        __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置一些heap参数 返回这个申请的heap</span><br><span class="line">    h = (heap_info *) p2;</span><br><span class="line">    h-&gt;size = size;</span><br><span class="line">    h-&gt;mprotect_size = size;</span><br><span class="line">    LIBC_PROBE (memory_heap_new, 2, h, h-&gt;size);</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看参数处理部分，相关的宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define HEAP_MIN_SIZE (32 * 1024) // 32K</span><br><span class="line">#define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) // x64 上是64M</span><br><span class="line">#define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long)) // 4 * [4|8] M</span><br></pre></td></tr></table></figure>
<p>保持size的大小在 HEAP_MIN_SIZE 与 HEAP_MAX_SIZE 之间</p>
<p>然后是 <code>size_t pagesize = GLRO (dl_pagesize);</code> 展开宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define GLRO(name) _##name // _dl_pagesize</span><br><span class="line">/* Cached value of `getpagesize ()&#x27;.  */</span><br><span class="line">EXTERN size_t _dl_pagesize;</span><br><span class="line">size_t _dl_pagesize = EXEC_PAGESIZE;</span><br><span class="line">#define EXEC_PAGESIZE   4096</span><br><span class="line"></span><br><span class="line">// 最终的形式是</span><br><span class="line">size_t pagesize = EXEC_PAGESIZE;// 4096 byte  也就是 4k</span><br></pre></td></tr></table></figure>

<p>然后是补齐的算法 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 补齐算法 size + size&amp;(base-1)</span><br><span class="line">#define ALIGN_UP(base, size)    ALIGN_DOWN ((base) + (size) - 1, (size))</span><br><span class="line">#define ALIGN_DOWN(base, size)  ((base) &amp; -((__typeof__ (base)) (size))) // base &amp; -size</span><br></pre></td></tr></table></figure>

<p>这段主要是通过 mmap 申请内存 使用到的一个重要的方法是 mmap 函数原型 <code>void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset)</code> 和 <code>int munmap(void* start, size_t length)</code> ，mmap 分配内存 munmap 释放内存，这些操作都是要切到内核态执行的，<br>|参数|例子|意义|<br>|–|–|–|<br>|void* start|NULL|内存分配开始的位置 写NULL 这个位置由内核决定|<br>|size_t length|[number]|分配内存的长度|<br>|int prot|PROT_EXEC:执行 PROT_READ:读 PROT_WRITE:写 PROT_NONE:不可访问|权限|<br>|int flags||文件类型 需要与 open 的时候使用的配对儿|<br>|int fd|-1|文件句柄 -1 是与匿名搭配使用|<br>|off_t offset|0|写入文件的偏移量|<br>这里代码逻辑的设计也是为了减少内核函数的调用，先看其如何通过一系列宏调用系统函数的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define MMAP_CALL(__nr, __addr, __len, __prot, __flags, __fd, __offset) INLINE_SYSCALL_CALL (__nr, __addr, __len, __prot, __flags, __fd, __offset)</span><br><span class="line">#define INLINE_SYSCALL_CALL(...) __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><span class="line">#define __INLINE_SYSCALL_DISP(b,...) __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">#define __INLINE_SYSCALL_NARGS(...) __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)</span><br><span class="line">#define __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span><br><span class="line"></span><br><span class="line">// 以上宏展开情况</span><br><span class="line">__SYSCALL_CONCAT (</span><br><span class="line">    __INLINE_SYSCALL,</span><br><span class="line">    1</span><br><span class="line">    )(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">#define __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span><br><span class="line">#define __SYSCALL_CONCAT_X(a,b)     a##b</span><br><span class="line"></span><br><span class="line">// 得到</span><br><span class="line">__INLINE_SYSCALL1(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">#define __INLINE_SYSCALL1(name, a1) INLINE_SYSCALL (name, 1, a1)</span><br><span class="line">#define INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)</span><br><span class="line"></span><br><span class="line">// 最终调用的内核方法是</span><br><span class="line">__syscall_mmap(__addr, __len, __prot, __flags, __fd, __offset)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中有一些宏在做 <code>##</code> 进行字符拼接的时候 做了两层嵌套，其原因是 在 <code>##</code> 连接的宏定义中 里面的字符不会在进行宏展开了，做一层嵌套的目的是 在前一层先做宏展开 然后在发给下一个宏做 <code>##</code> 以此实现宏展开的需要。<br>最终调用的方法是 <code>__syscall_mmap</code></p>
<p>然后是mmap分配内存的逻辑，先抽离出主要逻辑功能 主要分三个部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static char *aligned_heap_area;</span><br><span class="line">p2 = MAP_FAILED;</span><br><span class="line">if (aligned_heap_area) &#123;</span><br><span class="line">    p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">    //....#1...</span><br><span class="line">&#125;</span><br><span class="line">if (p2 == MAP_FAILED) &#123;</span><br><span class="line">    p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">    if (p1 != MAP_FAILED) &#123; </span><br><span class="line">        //...#2...</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        // ...#3....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在 aligned_heap_area 则按照 aligned_heap_area 作为内存开始地址进行扩展（#1 处代码），否则按照两倍的 HEAP_MAX_SIZE 进行内存的申请（#2 处代码），申请失败的话 再次尝试申请 HEAP_MAX_SIZE 的内存（#3 处代码）。由于mmap 返回的是申请成功的内存的起始位置，这里分配内存 有一个需求是：如果将内存地址(虚拟地址) 按照 HEAP_MAX_SIZE 的长度进行分段 ，new_heap 分配的内存正好在这个段上 起始地址和结束地址都是 HEAP_MAX_SIZE 对齐的 且 长度是 HEAP_MAX_SIZE。<br>当内存申请成功后，这个时候是有申请内存的结尾地址的，将这个地址赋值给 aligned_heap_area 方便下次分配内存的时候 可以直接确定分配内存开始位置 见代码 #1 处，但是在这个过程中内存很有可能被其他线程或进程申请到，这个变量就没有用了 也就是 #1 处的申请内存的代码会失败，<br>这个场景可能比较有限 所以代码 #1 处使用完后立即就将这个变量赋值为NULL了，这个场景可能比较适用连续的大段内存分配吧。</p>
<p>重点是 #2 处的代码，他会尝试分配 两倍 HEAP_MAX_SIZE 的内存，可能会奇怪为什么分配两段。ptmalloc 在通过new_heap 申请内存的时候 他想要申请一段长度为 HEAD_MAX_SIZE 长度的内存，且这段内存的起始内存地址与结束地址是与 HEAD_MAX_SIZE 对齐的，也就是说 分配到的内存地址起始是 <code>n * HEAD_MAX_SIZE</code> 结束地址是 <code>(n+1) * HEAD_MAX_SIZE</code>。<br>对于 mmap 函数 第一个参数是起始地址，一般会给 NULL 让内核决定起始地址，这样内核返回的地址很大情况不会是 HEAD_MAX_SIZE 的倍数，这个时候需要计算返回的内存地址的对齐地址，当然是需要向上对齐，因为前面的内存已经被其他线程占用了。如果我们申请的长度是 HEAD_MAX_SIZE ，如果返回的起始地址不对齐 就要再次申请一段内存补充整个内存长度为 HEAD_MAX_SIZE 但是当再次申请的时候有可能会被其他线程前先一步 这个时候补充的内存段与之前申请的内存段并不连续了，这样就很糟糕。所以ptmallloc在这里一次申请 <code>2 * HEAD_MAX_SIZE</code> 的内存 然后通过<code>__munmap</code>函数将多余的内存返还给系统，通过这个思路来看代码就很好理解了，可以参考下图：<br><img src="WX20190518-230344@2x.png" alt="内存的切割内存"><br>其中 p1 是mmap返回的地址 ，p1 以 HEAD_MAX_SIZE 向上对齐得到 p2 ，p2是我们想要的内存起始地址，同样需要将 p1 开始 长度 p2 - p1 的内存返还给系统，p2 - p1 也就是 ul。<br>同时还有尾部多余的内存需要返还给系统，我们最终需要的内存的结束内存地址是 <code>p2 + HEAP_MAX_SIZE</code> 这也是需要返还给系统的内存起始地址，然后是长度。申请两倍内存的结束地址是 <code>p1 + 2 * HEAP_MAX_SIZE</code> 得到尾部需要返还的内存长度是 <code>(p1 + 2 * HEAP_MAX_SIZE) - (p2 + HEAP_MAX_SIZE)</code> ，结合 <code>p2 - p1 = ul</code> 最终得到 <code>HEAP_MAX_SIZE - ul</code> 这也就是代码中的尾部返还系统内存的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">if (p1 != MAP_FAILED) &#123; // 成功分配两倍HEAP_MAX_SIZE长度的内存 p1 是内存起始地址</span><br><span class="line">    // p2 是 p1 以HEAP_MAX_SIZE向上对齐的地址</span><br><span class="line">    p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1));</span><br><span class="line">    ul = p2 - p1; // p1 需要向上补齐的长度</span><br><span class="line">    // 将头部多余的内存返还给系统</span><br><span class="line">    if (ul) __munmap (p1, ul);</span><br><span class="line">    // 返回的内存地址正好是对齐的 这时给变量aligned_heap_area赋值 给下一个连续的内存申请用 可以直接确定内存起始位置</span><br><span class="line">    else aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">    // 将尾部多余的内存返还给系统</span><br><span class="line">    __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 #3 处的代码，这里的代码好理解，当上一步分配两倍HEAP_MAX_SIZE长度内存的时候失败的话，这里尝试申请HEAP_MAX_SIZE长度内存，看看返回的地址是否为 以HEAP_MAX_SIZE对齐的起始内存地址，这里纯粹是在碰运气的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 申请 HEAP_MAX_SIZE 长度内存</span><br><span class="line">p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">if (p2 == MAP_FAILED) return 0; // 分配失败 返回</span><br><span class="line">// 分配的内存起始地址 p2 并不是以HEAP_MAX_SIZE对齐的 则返还内存 直接返回</span><br><span class="line">if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;</span><br><span class="line">    __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-内存的申请过程总结"><a href="#4-内存的申请过程总结" class="headerlink" title="4. 内存的申请过程总结"></a>4. 内存的申请过程总结</h2>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/c/" rel="tag">c</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/glibc/" rel="tag">glibc</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/malloc/" rel="tag">malloc</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/ptmalloc/" rel="tag">ptmalloc</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/%E5%86%85%E5%AD%98/" rel="tag">内存</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-int-malloc%E4%B8%8Echunk%E5%90%88%E5%B9%B6/"
                    data-tooltip="malloc源码分析-int_malloc与chunk合并"
                    aria-label="上一篇: malloc源码分析-int_malloc与chunk合并"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                    data-tooltip="malloc源码分析-设计思路与基本数据结构"
                    aria-label="下一篇: malloc源码分析-设计思路与基本数据结构"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 fantiq. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-int-malloc%E4%B8%8Echunk%E5%90%88%E5%B9%B6/"
                    data-tooltip="malloc源码分析-int_malloc与chunk合并"
                    aria-label="上一篇: malloc源码分析-int_malloc与chunk合并"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                    data-tooltip="malloc源码分析-设计思路与基本数据结构"
                    aria-label="下一篇: malloc源码分析-设计思路与基本数据结构"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://fantiq.github.io/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Earena%E7%9A%84%E5%88%9B%E5%BB%BA/"
                        aria-label="分享到 Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">fantiq</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                China HangZhou
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-ffzlst6ssezilzbbgybxfwuegfobjsmomzthas0h8hymsrrzox2o6dre4owp.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
