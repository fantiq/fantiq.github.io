
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="代码狗">
    <title>c语言基础-类型到底是什么 - 代码狗</title>
    <meta name="author" content="fantiq">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fantiq","sameAs":["https://github.com/fantiq"],"image":"avatar.jpg"},"articleBody":"在c语言的代码中，变量都是需要指定变量的类型，要讲清楚变量类型是什么需要先讲清楚 程序与计算机硬件之间的关系。程序其实是数据结构与算法的组合，其中的数据结构主要是数据，数据对应到代码中就是各个变量（这里将变量常量等统一称作变量来看待），算法指的是程序中的判断逻辑和基本的数学计算，其实程序中的逻辑判断本质上也是计算（计算机中的计算其实是 布尔运算 其可以支持程序中的逻辑判断和数学计算）。\n\n1. 变量类型是什么程序中的计算是依赖计算机中的CPU硬件来实现，CPU的计算是对数据进行计算的，一次计算的过程是针对单个数据进行的，这些数据（也就是我们程序中的变量）是临时存储在CPU寄存器中方便CPU的计算，大量的变量数据是存储在内存中的。CPU在计算的时候 从内存中读取数据 到 寄存器 然后再进行计算 将计算的结果再写入到内存。\n当然程序要实现这些操作（内存的读写 CPU 的计算）都需要通过操作系统来完成，操作系统执行这些程序的机器码 通过CPU这个中控实现将程序的数据加载到内存中，然后CPU对内存数据进行读写，CPU通过其内部的寄存器对数据进行临时的存储，归根结底 我们程序中的变量是需要存储到内存中的。关于内存的硬件原理可以参考 内存的工作原理，内存是以byte为一个最小的操作单位，当然在内存中其最小的硬件实现单位是 bit，对外部是以byte为最小单位。内存可以当作连续的一系列用于存储数据的格子，每个格子的存储单位是 byte，当然每个格子都需要一个地址编号，这些编号是连续的。\n变量存储到内存中需要两个重要信息，内存的起始地址 和 内存占用长度，知道了这两个信息 就可以实现变量数据的读写。这些信息需要程序告诉操作系统，由操作系统通过CPU控制内存实现，对于内存地址 操作系统通过虚拟内存的形式对内存管理，所以操作系统可以自动分配合适的内存存储程序中的变量，然后还有需要多少的内存空间，这个信息需要程序来给出，程序是通过变量类型的形式给出了需要占用的内存长度，比如c语言中的类型对应需要占用的内存空间如下：\n\n\n\n类型\n长度(byte)\n\n\n\nchar\n1\n\n\nshort\n2\n\n\nint\n4\n\n\nlong\n8\n\n\nfloat\n4\n\n\ndouble\n8\n\n\n所以，变量的类型是为了告诉操作系统需要分配多少的内存空间来存储这个变量，变量在内存中的存储形式如下图所示：\n2. 基础变量在c语言中定义的变量有多种类型，基础类型的有 整型的 char short int long 和 浮点的 float double，这些数据存储到内存中都是以二进制的形式存储。\n2.1 变量在内存中的存储形式2.1.1 有符号与无符号变量对于数字 存在负号的情况需要考虑，所以在定义变量的时候还需要指定是有符号还是无符号，不定义是否有符号的话 默认是有符号的 定义形式如下：\n123456// 以下是定义有符号的形式signed int num2;// 定义有符号变量 也可以不写 默认是 signedint num3;// 定义无符号的变量 需要关键词 unsigned unsigned int num1;\n\n符号关键词影响变量值在内存中的存储形式，同时也会影响从内存中读取后对这个值的看待形式，计算机中对负数的存储形式可以参考 负数的存储-原码 反码 补码。计算机如果需要表达负数 就需要将一般的值拿出来表达负数，计算机中是将高位拿出来表示负数的，所以负数在二进制的形式中最高位是1，负数的内存存储形式与无符号变量的一些值的存储形式是一样的，当这些值在被读取出来的时候要根据这个 关键词 的定义决定将这个值当作负数看待还是当作整数看待。如下程序：\n1234567int main() &#123;    char m = -128; // 10000000    unsigned char n = (unsigned char)m;    printf(&quot;%d\\t%u\\n&quot;, m, n);&#125;---------- result -----------128    128\n变量 m 是有符号变量，其存储在内存中的形式是 10000000 ，然后将m赋值给一个无符号变量 n ，这时 n 变量的值在内存中的存储形式与 m 一样，当输出的时候，同样的内存存储形式 由于变量的有无符号定义不同 其结果也不同了。\n2.1.2 浮点型变量的存储形式C语言float、double的内存表示\n2.2 指针型变量与非指针型变量起始在程序中 变量分为两种的 一种是上面讲的一般变量 另一种就是指针型变量，指针型变量的定义形式与一般变量的定义形式略有不同，指针型变量在类型定义后有一个修饰符 *\n1234// 一般变量的定义signed int p;// 指针型变量的定义signed int * q;\n\n指针型变量与一般变量有所不同，一般变量存储程序计算需要的数据，指针变量存储的是一般变量存储在内存的内存地址，所以一般变量占用的内存空间由变量定义的类型决定，指针型变量由于存储的是内存地址，在x64架构上 其占用的内存空间是固定的 8 byte，其并不会受自己定义类型的影响，因为指针型变量的类型是为了在读取变量的时候需要读取多少内存空间。上面我们讲过变量存储在内存中重要的信息是 内存起始地址和需要占用的内存空间，占用的内存空间有一般变量的类型决定，内存起始地址是操作系统确定的，程序中也是可以读取到这个内存地址的，其操作符是 &amp; ，其返回的是内存地址 。同样可以通过内存地址读取内存中的值，操作符是 *，这个操作符只能作用在指针类型的变量上，指针变量的值是内存的起始地址，指针变量定义的类型确定了读取内存的长度，这些信息就能确定读取值了。\n12345678910111213141516171819202122int main() &#123;    // 定义一个变量    char num = 120;    // 取地址    // 将内存地址赋值给一个指针型变量    char * num_ptr = &amp;num;    // 将内存地址赋值给一个一般变量    unsigned long num_addr = &amp;num;    // 将内存地址存储在一个指针型变量 只是这个变量的类型不对    short * num_ptrl = &amp;num;    // 将这三个值打印出来发现是相等的，这说明 &amp; 返回的起始就是数字，也说明了指针型变量的长度是固定的 8 byte 不受变量类型影响    printf(&quot;%#X\\t%#X\\n&quot;, num_ptr, num_addr);    // 通过内存地址读取其中的值 char * 类型的变量读取的值正常 而 short * 类型的变量读取的值不正常，这是由于 指针型变量类型定义为 short    // 这样 * 操作会从起始地址向后读取2byte长度的数据 导致最终结果的错误    printf(&quot;%d\\t%d\\n&quot;, *num_ptr, *num_ptrl);    // 操作 * 作用的非指针变量 编译不会通过的    //printf(&quot;%d\\n&quot;, *num_addr);&#125;---------- result ----------0XED459A6F  0XED459A6F  0XED459A6F120 -30600\n\n指针型变量是可以参与运算的，只不过其不像一般变量 参与运算是数学上的元素，指针型变量参与运算其实是地址偏移的计算，假设指针变量 int * p 对其进行计算 p+5 相当于 内存地址向高位移动 5 个 int类型的内存长度后的内存地址 p + 5 等同于 内存起始地址 + 5 * sizeof(int)\n123456789101112131415161718#define DEFAULT_ADDRESS 1Uint main() &#123;    char * p1 = DEFAULT_ADDRESS;    short * p2 = DEFAULT_ADDRESS;    int * p3 = DEFAULT_ADDRESS;    long * p4 = DEFAULT_ADDRESS;    // 计算起始地址 起始地址+4 两个地址的差除以4得到的偏移步长 正好是对应指针型变量对应的类型长度    printf(&quot;%lu, %lu, %lu\\n&quot;, p1, p1+4, ((unsigned char)(p1+4)-(unsigned char)p1) / 4);    printf(&quot;%lu, %lu, %lu\\n&quot;, p2, p2+4, ((unsigned short)(p2+4)-(unsigned short)p2) / 4);    printf(&quot;%lu, %lu, %lu\\n&quot;, p3, p3+4, ((unsigned int)(p3+4)-(unsigned int)p3) / 4);    printf(&quot;%lu, %lu, %lu\\n&quot;, p4, p4+4, ((unsigned long)(p4+4)-(unsigned long)p4) / 4);&#125;---------- result ----------1, 5, 11, 9, 21, 17, 41, 33, 8\n3. 数组数组是同一种变量类型的多个值的集合，这些值在内存中是相邻的，数组变量的定义形式如下：\n1int arr[8] = &#123;初始化的值&#125;;\n其中变量名出 arr 是一个指针类型的变量 这是与其他变量定义不同的地方。其次是 数组变量读取数据是通过下标的形式 arr[3] 其本质是内存地址的偏移，也是内存地址偏移的一种形式。\n12345678910111213141516int main() &#123;    int arr[5] = &#123;1,2,3,4,5&#125;;    // 数组变量打印出来是内存地址    printf(&quot;%p\\n&quot;, arr);    // 可以直接对数组变量进行内存取值操作(*) 说明数组变量是指针类型的变量 数据类型是定义的 int    // 取地址的值正等于数组中的第一个值    printf(&quot;%d\\t%d\\n&quot;, *arr, arr[0]);    // 通过地址偏移取到的值 与 数组下标取到的值相等    // 说明数组下标取值的形式 其实是一种内存地址偏移取值的简写形式    printf(&quot;%d\\t%d\\n&quot;, *(arr+3), arr[3]);&#125;---------- result ----------0x7ffee6838a501   14   4\n数组下标取值是内存地址偏移取值的一种简化形式 arr[n] 等价于 *(arr+n)\n4. 结构体 与 联合体结构体与联合体是不同类型变量的组合，结构体 联合体作为一个大的变量 其实是各个标量的变量的组合，各个变量是他们的属性，这些变量在内存中存储的位置是连续的\n4.1 结构体 struct结构体的定义与使用\n123456789101112131415161718192021222324定义结构体类型 foostruct foo &#123;    char a;    int b;&#125;;int main() &#123;    // 声明一个 struct foo 类型的变量    // 可以以这种形式在定义变量的时候进行属性初始化    struct foo f = &#123;        .a = 2,        .b = 102    &#125;;    // 读取struct类型变量中各个属性    printf(&quot;%d\\t%d\\n&quot;, f.a, f.b);    // 也可以单个属性进行赋值    f.a = 4;    f.b = 1022;    // 读取新值    printf(&quot;%d\\t%d\\n&quot;, f.a, f.b);&#125;---------- result ----------2   1024   1022\n\n同样 结构体变量同样存在一般变量与指针变量，可以通过操作 &amp; 获取变量的内存地址 然后通过计算内存偏移量 找到存储属性值的内存地址，这样的形式读取内存中的值。\n12345678910int main() &#123;    struct foo f = &#123;        .a = 2,        .b = 102    &#125;;    struct foo * fp = &amp;f;    // 通过指针的形式读取内存中的值 属性 a b 都有变量类型可以确定需要读取多少内存 以及计算内存地址偏移量    printf(&quot;%d\\t%d\\n&quot;, fp-&gt;a, fp-&gt;b);&#125;\n\n尝试通过计算内存地址的形式读取struct 属性\n123456789101112131415161718192021struct foo &#123;    int a;    char b;&#125;;int main() &#123;    // 定义变量    struct foo f = &#123;.a = 100, .b = 33&#125;;    // 读取内存地址 这里将内存地址的类型定义为 char *     // 目的是为了手工计算内存偏移量 char * 占一个字节 正对应内存最小单位    // 在进行偏移计算的时候 +1 整对应一个内存地址的移动    char * fp = (char *)&amp;f;    // 读取第一个属性 a 当然fp可以不用+0计算的    // 计算后的值还是指针型变量 类型为 char * 我们需要告诉系统 需要读取多少内存地址就要将这个类型转换成 对应内存长度的类型    // 所以这里先将计算得到的值 转换成类型 (int *) 然后在进行读取操作 *    printf(&quot;%d\\n&quot;, *(int *)(fp+0));    // 读取第二个属性 b 第一个属性a是 int 占用内存 4个byte 属性b存储在a的后面 需要偏移内存 4个byte 得到 fp+4    // 这里同样要考虑读取内存长度 需要类型转换 这里的转换其实可以省略 因为计算后的变量类型就是 (char *)    printf(&quot;%d\\n&quot;, *(char *)(fp+4));&#125;---------- result ----------100 33\n\n4.1.2 内存对齐若将上面结构体属性顺序调换，通过内存读取的形式是否能够得到正确的值？\n12345678910111213struct foo &#123;    char b;    int a;&#125;;int main() &#123;    struct foo f = &#123;.a = 116, .b = 33&#125;;    char * fp = (char *)&amp;f;    printf(&quot;%d\\n&quot;, *(fp+0));    printf(&quot;%d\\n&quot;, *(int *)(fp+1));&#125;---------- result ----------331946157056\n第一个属性读取正确 第二个属性读取出现了问题，属性 b 是char类型占用1个byte第二个变量存储的位置本应该是内存起始地址+1byte的地方，但是这里的结果表明第二个属性并不在这个位置，事实上他在 偏移4byte的位置，上面的代码改成 printf(&quot;%d\\n&quot;, *(int *)(fp+4)) 就能读取到正确的结果(116) 这就是struct中的内存对齐。\n要对struct 成员进行内存对齐的原因是 为了提升CPU对数据读取的效率，在大多数的架构中 CPU每次寻址 读取的是32bit的数据 也就是 4byte，如果变量在存储的时候没有内存对齐，CPU是以对齐的形式(32bit)读取数据的，这样就要读取两次 然后对数据重新组合才能得到值，这样提升了复杂度。\n一般的程序中都是以 4 byte 内存对齐 可以通过宏定义来改变对齐值 #pragma pack &lt;n&gt;，内存对齐要达到的目的就是 在一个 4 byte的内存块中存储的下一个或多个变量，不能让变量跨两个 4 byte 内存块存储。对于变量 int long 都是 4byte倍数，short是 2byte 如果是这些变量存储是不需要考虑对齐的，怎样的存储都会对齐，但是出现的 char 类型占用 1byte内存就会 出现不对齐的情况了。内存对齐其实是解决如何存储char类型变量不使变量跨内存块存储的问题，并且在struct 中属性之间也是要按顺序进行存储的，不同的顺序会导致整个结构体需要占用的内存空间不同。\n4.2 联合体 union联合体如何结构体也是多个变量的组合，不同点是他么占用的内存空间不同，结构体会给每一个属性分配内存空间，联合体只会分配一个最大属性存储需要的空间。所以联合体的内存空间中只能存储所有属性中的一个，各个属性可以定义不同类型，这些类型定义决定在读写内存的时候需要的内存空间偏移量。\n12345678910111213union foo &#123;    char a;    int b;&#125;;int main() &#123;    union foo f;    f.a = 33;    f.b = 66;    // 最后的赋值会覆盖整个联合体申请的内存    printf(&quot;%d\\t%d\\n&quot;, f.a, f.b);&#125;---------- result ----------66  66\n当一个小变量覆盖一个大变量的时候，其只会覆盖低地址需要覆盖的部分，读取也只会读取类型指定的内存长度的数据\n123456789101112131415161718union foo &#123;    char a;    int b;&#125;;int main() &#123;    union foo f;    f.b = 0x2310;    // a 是 char型 只会将值写入到地址前1byte    f.a = 0x40;    printf(&quot;%#x\\n&quot;, f.b);    // 使用 属性b 填充一个 int 长度的值    f.b = 0x77889920;    // 读取属性 a 只会读取 1 byte的数据    printf(&quot;%#x\\n&quot;, f.a);&#125;---------- result ----------0x23400x20\n整形提升看一个奇怪的情况\n12345char c = 129;char * p = &amp;c;printf(&quot;%u\\n&quot;, *p);---------- result ----------4294967169\n以上结果 已经超出了char所能表示的范围，有符号的 char 类型存储了一个值 129 这个值存储后实际表示的是负值 可以通过 printf(&quot;%d&quot;, c); 查看 其结果应该是 -127 ，这里我们将其以无符号的形式输出 就还应该得到 129 ，结果却得到一个更大的值，造成这种情况的原因是 整形提升。\n我们的变量是存储在内存 char占用1byte，当需要计算的时候 CPU要将值读取到寄存器中的，寄存器一般都是 32位了也就是能存储 4byte的数据，当数据少于4byted的时候 CPU要做额外的工作处理这种输入不一致问题，CPU选择的是将变量的高位填充数据 既不影响计算 也不影响寄存器的存储，这个过程叫 整形提升。\n其过程如下，如果是正数 高位填充 0 ，如果是负数 高位填充 1，将变量值补充对齐成 4 byte 的信号。正数高位补充 0 很明显不会造成影响，负数高位补充1的形式一时难以看出是否有影响，对于负数在内存中是以补码形式存储的，负数其实是正数在数轴上的对称位置上，负数的存储形式最高位一定是 1 ，当对其更高位补充1时 其表达的负数的值并没有变化：\n12四位的 1001        对应表达的有符号值是 -1八位的 10000001    对应表达的有符号值是 -1\n\n熟悉负数补码的计算方式的话就很好理解了，可以看作 高位的1是表示正负数 剩下位是值。\n","dateCreated":"2019-05-26T14:04:33+08:00","dateModified":"2019-06-03T15:05:19+08:00","datePublished":"2019-05-26T14:04:33+08:00","description":"在c语言的代码中，变量都是需要指定变量的类型，要讲清楚变量类型是什么需要先讲清楚 程序与计算机硬件之间的关系。程序其实是数据结构与算法的组合，其中的数据结构主要是数据，数据对应到代码中就是各个变量（这里将变量常量等统一称作变量来看待），算法指的是程序中的判断逻辑和基本的数学计算，其实程序中的逻辑判断本质上也是计算（计算机中的计算其实是 布尔运算 其可以支持程序中的逻辑判断和数学计算）。","headline":"c语言基础-类型到底是什么","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"},"publisher":{"@type":"Organization","name":"fantiq","sameAs":["https://github.com/fantiq"],"image":"avatar.jpg","logo":{"@type":"ImageObject","url":"avatar.jpg"}},"url":"https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/","keywords":"c"}</script>
    <meta name="description" content="在c语言的代码中，变量都是需要指定变量的类型，要讲清楚变量类型是什么需要先讲清楚 程序与计算机硬件之间的关系。程序其实是数据结构与算法的组合，其中的数据结构主要是数据，数据对应到代码中就是各个变量（这里将变量常量等统一称作变量来看待），算法指的是程序中的判断逻辑和基本的数学计算，其实程序中的逻辑判断本质上也是计算（计算机中的计算其实是 布尔运算 其可以支持程序中的逻辑判断和数学计算）。">
<meta property="og:type" content="blog">
<meta property="og:title" content="c语言基础-类型到底是什么">
<meta property="og:url" content="https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/index.html">
<meta property="og:site_name" content="代码狗">
<meta property="og:description" content="在c语言的代码中，变量都是需要指定变量的类型，要讲清楚变量类型是什么需要先讲清楚 程序与计算机硬件之间的关系。程序其实是数据结构与算法的组合，其中的数据结构主要是数据，数据对应到代码中就是各个变量（这里将变量常量等统一称作变量来看待），算法指的是程序中的判断逻辑和基本的数学计算，其实程序中的逻辑判断本质上也是计算（计算机中的计算其实是 布尔运算 其可以支持程序中的逻辑判断和数学计算）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/2019-06-03-12.51.51.png">
<meta property="article:published_time" content="2019-05-26T06:04:33.000Z">
<meta property="article:modified_time" content="2019-06-03T07:05:19.393Z">
<meta property="article:author" content="fantiq">
<meta property="article:tag" content="c">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/2019-06-03-12.51.51.png">
    
    
        
    
    
        <meta property="og:image" content="https://fantiq.github.io/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-bo1h1ya3kmjmd94f0k5yc43ngmshulfcyc8apgyrr2pfx48g1zk5lyp9do8g.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            代码狗
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">fantiq</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/fantiq"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            c语言基础-类型到底是什么
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-05-26T14:04:33+08:00">
	
		    5月 26, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/c/">c</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>在c语言的代码中，变量都是需要指定变量的类型，要讲清楚变量类型是什么需要先讲清楚 程序与计算机硬件之间的关系。程序其实是<code>数据结构</code>与<code>算法</code>的组合，其中的数据结构主要是数据，数据对应到代码中就是各个变量（这里将变量常量等统一称作变量来看待），算法指的是程序中的判断逻辑和基本的数学计算，其实程序中的逻辑判断本质上也是计算（计算机中的计算其实是 布尔运算 其可以支持程序中的逻辑判断和数学计算）。</p>
<span id="more"></span>
<h2 id="1-变量类型是什么"><a href="#1-变量类型是什么" class="headerlink" title="1. 变量类型是什么"></a>1. 变量类型是什么</h2><p>程序中的计算是依赖计算机中的CPU硬件来实现，CPU的计算是对数据进行计算的，一次计算的过程是针对单个数据进行的，这些数据（也就是我们程序中的变量）是临时存储在CPU寄存器中方便CPU的计算，大量的变量数据是存储在内存中的。CPU在计算的时候 从内存中读取数据 到 寄存器 然后再进行计算 将计算的结果再写入到内存。</p>
<p>当然程序要实现这些操作（内存的读写 CPU 的计算）都需要通过操作系统来完成，操作系统执行这些程序的机器码 通过CPU这个中控实现将程序的数据加载到内存中，然后CPU对内存数据进行读写，CPU通过其内部的寄存器对数据进行临时的存储，归根结底 我们程序中的变量是需要存储到内存中的。关于内存的硬件原理可以参考 <a href="%E5%86%85%E5%AD%98-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md">内存的工作原理</a>，内存是以byte为一个最小的操作单位，当然在内存中其最小的硬件实现单位是 bit，对外部是以byte为最小单位。内存可以当作连续的一系列用于存储数据的格子，每个格子的存储单位是 byte，当然每个格子都需要一个地址编号，这些编号是连续的。</p>
<p>变量存储到内存中需要两个重要信息，<strong>内存的起始地址</strong> 和 <strong>内存占用长度</strong>，知道了这两个信息 就可以实现变量数据的读写。这些信息需要程序告诉操作系统，由操作系统通过CPU控制内存实现，对于内存地址 操作系统通过虚拟内存的形式对内存管理，所以操作系统可以自动分配合适的内存存储程序中的变量，然后还有需要多少的内存空间，这个信息需要程序来给出，程序是通过变量类型的形式给出了需要占用的内存长度，比如c语言中的类型对应需要占用的内存空间如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度(byte)</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
</tbody></table>
<p>所以，变量的类型是为了告诉操作系统<strong>需要分配多少的内存空间来存储这个变量</strong>，变量在内存中的存储形式如下图所示：<br><img src="2019-06-03-12.51.51.png" alt="变量在内存中的存储形式"></p>
<h2 id="2-基础变量"><a href="#2-基础变量" class="headerlink" title="2. 基础变量"></a>2. 基础变量</h2><p>在c语言中定义的变量有多种类型，基础类型的有 整型的 <code>char short int long</code> 和 浮点的 <code>float double</code>，这些数据存储到内存中都是以二进制的形式存储。</p>
<h4 id="2-1-变量在内存中的存储形式"><a href="#2-1-变量在内存中的存储形式" class="headerlink" title="2.1 变量在内存中的存储形式"></a>2.1 变量在内存中的存储形式</h4><h5 id="2-1-1-有符号与无符号变量"><a href="#2-1-1-有符号与无符号变量" class="headerlink" title="2.1.1 有符号与无符号变量"></a>2.1.1 有符号与无符号变量</h5><p>对于数字 存在负号的情况需要考虑，所以在定义变量的时候还需要指定是有符号还是无符号，不定义是否有符号的话 默认是有符号的 定义形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 以下是定义有符号的形式</span><br><span class="line">signed int num2;</span><br><span class="line">// 定义有符号变量 也可以不写 默认是 signed</span><br><span class="line">int num3;</span><br><span class="line">// 定义无符号的变量 需要关键词 unsigned </span><br><span class="line">unsigned int num1;</span><br></pre></td></tr></table></figure>

<p>符号关键词影响变量值在内存中的存储形式，同时也会影响从内存中读取后对这个值的看待形式，计算机中对负数的存储形式可以参考 <a href="%E8%B4%9F%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8-%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81.md">负数的存储-原码 反码 补码</a>。计算机如果需要表达负数 就需要将一般的值拿出来表达负数，计算机中是将高位拿出来表示负数的，所以负数在二进制的形式中最高位是1，负数的内存存储形式与无符号变量的一些值的存储形式是一样的，当这些值在被读取出来的时候要根据这个 关键词 的定义决定将这个值当作负数看待还是当作整数看待。如下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    char m = -128; // 10000000</span><br><span class="line">    unsigned char n = (unsigned char)m;</span><br><span class="line">    printf(&quot;%d\t%u\n&quot;, m, n);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">-128    128</span><br></pre></td></tr></table></figure>
<p>变量 m 是有符号变量，其存储在内存中的形式是 <code>10000000</code> ，然后将m赋值给一个无符号变量 n ，这时 n 变量的值在内存中的存储形式与 m 一样，当输出的时候，同样的内存存储形式 由于变量的有无符号定义不同 其结果也不同了。</p>
<h5 id="2-1-2-浮点型变量的存储形式"><a href="#2-1-2-浮点型变量的存储形式" class="headerlink" title="2.1.2 浮点型变量的存储形式"></a>2.1.2 浮点型变量的存储形式</h5><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/3095.html">C语言float、double的内存表示</a></p>
<h4 id="2-2-指针型变量与非指针型变量"><a href="#2-2-指针型变量与非指针型变量" class="headerlink" title="2.2 指针型变量与非指针型变量"></a>2.2 指针型变量与非指针型变量</h4><p>起始在程序中 变量分为两种的 一种是上面讲的一般变量 另一种就是指针型变量，指针型变量的定义形式与一般变量的定义形式略有不同，指针型变量在类型定义后有一个修饰符 <code>*</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 一般变量的定义</span><br><span class="line">signed int p;</span><br><span class="line">// 指针型变量的定义</span><br><span class="line">signed int * q;</span><br></pre></td></tr></table></figure>

<p>指针型变量与一般变量有所不同，一般变量存储程序计算需要的数据，指针变量存储的是一般变量存储在内存的内存地址，所以一般变量占用的内存空间由变量定义的类型决定，指针型变量由于存储的是内存地址，在x64架构上 其占用的内存空间是<strong>固定的 8 byte</strong>，其并不会受自己定义类型的影响，因为指针型变量的类型是为了在读取变量的时候需要<strong>读取多少内存空间</strong>。上面我们讲过变量存储在内存中重要的信息是 内存起始地址和需要占用的内存空间，占用的内存空间有一般变量的类型决定，内存起始地址是操作系统确定的，程序中也是可以读取到这个内存地址的，其操作符是 <code>&amp;</code> ，其返回的是内存地址 。同样可以通过内存地址读取内存中的值，操作符是 <code>*</code>，这个操作符只能作用在指针类型的变量上，指针变量的值是内存的起始地址，指针变量定义的类型确定了读取内存的长度，这些信息就能确定读取值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    // 定义一个变量</span><br><span class="line">    char num = 120;</span><br><span class="line">    // 取地址</span><br><span class="line">    // 将内存地址赋值给一个指针型变量</span><br><span class="line">    char * num_ptr = &amp;num;</span><br><span class="line">    // 将内存地址赋值给一个一般变量</span><br><span class="line">    unsigned long num_addr = &amp;num;</span><br><span class="line">    // 将内存地址存储在一个指针型变量 只是这个变量的类型不对</span><br><span class="line">    short * num_ptrl = &amp;num;</span><br><span class="line">    // 将这三个值打印出来发现是相等的，这说明 &amp; 返回的起始就是数字，也说明了指针型变量的长度是固定的 8 byte 不受变量类型影响</span><br><span class="line">    printf(&quot;%#X\t%#X\n&quot;, num_ptr, num_addr);</span><br><span class="line">    // 通过内存地址读取其中的值 char * 类型的变量读取的值正常 而 short * 类型的变量读取的值不正常，这是由于 指针型变量类型定义为 short</span><br><span class="line">    // 这样 * 操作会从起始地址向后读取2byte长度的数据 导致最终结果的错误</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, *num_ptr, *num_ptrl);</span><br><span class="line"></span><br><span class="line">    // 操作 * 作用的非指针变量 编译不会通过的</span><br><span class="line">    //printf(&quot;%d\n&quot;, *num_addr);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">0XED459A6F  0XED459A6F  0XED459A6F</span><br><span class="line">120 -30600</span><br></pre></td></tr></table></figure>

<p>指针型变量是可以参与运算的，只不过其不像一般变量 参与运算是数学上的元素，指针型变量参与运算其实是地址偏移的计算，假设指针变量 <code>int * p</code> 对其进行计算 p+5 相当于 内存地址向高位移动 5 个 int类型的内存长度后的内存地址 p + 5 等同于 <code>内存起始地址 + 5 * sizeof(int)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define DEFAULT_ADDRESS 1U</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char * p1 = DEFAULT_ADDRESS;</span><br><span class="line">    short * p2 = DEFAULT_ADDRESS;</span><br><span class="line">    int * p3 = DEFAULT_ADDRESS;</span><br><span class="line">    long * p4 = DEFAULT_ADDRESS;</span><br><span class="line">    // 计算起始地址 起始地址+4 两个地址的差除以4得到的偏移步长 正好是对应指针型变量对应的类型长度</span><br><span class="line">    printf(&quot;%lu, %lu, %lu\n&quot;, p1, p1+4, ((unsigned char)(p1+4)-(unsigned char)p1) / 4);</span><br><span class="line">    printf(&quot;%lu, %lu, %lu\n&quot;, p2, p2+4, ((unsigned short)(p2+4)-(unsigned short)p2) / 4);</span><br><span class="line">    printf(&quot;%lu, %lu, %lu\n&quot;, p3, p3+4, ((unsigned int)(p3+4)-(unsigned int)p3) / 4);</span><br><span class="line">    printf(&quot;%lu, %lu, %lu\n&quot;, p4, p4+4, ((unsigned long)(p4+4)-(unsigned long)p4) / 4);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">1, 5, 1</span><br><span class="line">1, 9, 2</span><br><span class="line">1, 17, 4</span><br><span class="line">1, 33, 8</span><br></pre></td></tr></table></figure>
<h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><p>数组是同一种变量类型的多个值的集合，这些值在内存中是相邻的，数组变量的定义形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[8] = &#123;初始化的值&#125;;</span><br></pre></td></tr></table></figure>
<p>其中变量名出 arr 是一个指针类型的变量 这是与其他变量定义不同的地方。其次是 数组变量读取数据是通过下标的形式 <code>arr[3]</code> 其本质是内存地址的偏移，也是内存地址偏移的一种形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int arr[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    // 数组变量打印出来是内存地址</span><br><span class="line">    printf(&quot;%p\n&quot;, arr);</span><br><span class="line">    // 可以直接对数组变量进行内存取值操作(*) 说明数组变量是指针类型的变量 数据类型是定义的 int</span><br><span class="line">    // 取地址的值正等于数组中的第一个值</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, *arr, arr[0]);</span><br><span class="line">    // 通过地址偏移取到的值 与 数组下标取到的值相等</span><br><span class="line">    // 说明数组下标取值的形式 其实是一种内存地址偏移取值的简写形式</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, *(arr+3), arr[3]);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">0x7ffee6838a50</span><br><span class="line">1   1</span><br><span class="line">4   4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组下标取值是内存地址偏移取值的一种简化形式 <code>arr[n]</code> 等价于 <code>*(arr+n)</code></p>
<h2 id="4-结构体-与-联合体"><a href="#4-结构体-与-联合体" class="headerlink" title="4. 结构体 与 联合体"></a>4. 结构体 与 联合体</h2><p>结构体与联合体是不同类型变量的组合，结构体 联合体作为一个大的变量 其实是各个标量的变量的组合，各个变量是他们的属性，这些变量在内存中存储的位置是连续的</p>
<h4 id="4-1-结构体-struct"><a href="#4-1-结构体-struct" class="headerlink" title="4.1 结构体 struct"></a>4.1 结构体 struct</h4><p>结构体的定义与使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">定义结构体类型 foo</span><br><span class="line">struct foo &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 声明一个 struct foo 类型的变量</span><br><span class="line">    // 可以以这种形式在定义变量的时候进行属性初始化</span><br><span class="line">    struct foo f = &#123;</span><br><span class="line">        .a = 2,</span><br><span class="line">        .b = 102</span><br><span class="line">    &#125;;</span><br><span class="line">    // 读取struct类型变量中各个属性</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, f.a, f.b);</span><br><span class="line">    // 也可以单个属性进行赋值</span><br><span class="line">    f.a = 4;</span><br><span class="line">    f.b = 1022;</span><br><span class="line">    // 读取新值</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, f.a, f.b);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">2   102</span><br><span class="line">4   1022</span><br></pre></td></tr></table></figure>

<p>同样 结构体变量同样存在一般变量与指针变量，可以通过操作 &amp; 获取变量的内存地址 然后通过计算内存偏移量 找到存储属性值的内存地址，这样的形式读取内存中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    struct foo f = &#123;</span><br><span class="line">        .a = 2,</span><br><span class="line">        .b = 102</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct foo * fp = &amp;f;</span><br><span class="line">    // 通过指针的形式读取内存中的值 属性 a b 都有变量类型可以确定需要读取多少内存 以及计算内存地址偏移量</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, fp-&gt;a, fp-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试通过计算内存地址的形式读取struct 属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct foo &#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    struct foo f = &#123;.a = 100, .b = 33&#125;;</span><br><span class="line">    // 读取内存地址 这里将内存地址的类型定义为 char * </span><br><span class="line">    // 目的是为了手工计算内存偏移量 char * 占一个字节 正对应内存最小单位</span><br><span class="line">    // 在进行偏移计算的时候 +1 整对应一个内存地址的移动</span><br><span class="line">    char * fp = (char *)&amp;f;</span><br><span class="line">    // 读取第一个属性 a 当然fp可以不用+0计算的</span><br><span class="line">    // 计算后的值还是指针型变量 类型为 char * 我们需要告诉系统 需要读取多少内存地址就要将这个类型转换成 对应内存长度的类型</span><br><span class="line">    // 所以这里先将计算得到的值 转换成类型 (int *) 然后在进行读取操作 *</span><br><span class="line">    printf(&quot;%d\n&quot;, *(int *)(fp+0));</span><br><span class="line">    // 读取第二个属性 b 第一个属性a是 int 占用内存 4个byte 属性b存储在a的后面 需要偏移内存 4个byte 得到 fp+4</span><br><span class="line">    // 这里同样要考虑读取内存长度 需要类型转换 这里的转换其实可以省略 因为计算后的变量类型就是 (char *)</span><br><span class="line">    printf(&quot;%d\n&quot;, *(char *)(fp+4));</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">100 33</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-内存对齐"><a href="#4-1-2-内存对齐" class="headerlink" title="4.1.2 内存对齐"></a>4.1.2 内存对齐</h4><p>若将上面结构体属性顺序调换，通过内存读取的形式是否能够得到正确的值？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct foo &#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    struct foo f = &#123;.a = 116, .b = 33&#125;;</span><br><span class="line">    char * fp = (char *)&amp;f;</span><br><span class="line">    printf(&quot;%d\n&quot;, *(fp+0));</span><br><span class="line">    printf(&quot;%d\n&quot;, *(int *)(fp+1));</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">33</span><br><span class="line">1946157056</span><br></pre></td></tr></table></figure>
<p>第一个属性读取正确 第二个属性读取出现了问题，属性 b 是char类型占用1个byte第二个变量存储的位置本应该是内存起始地址+1byte的地方，但是这里的结果表明第二个属性并不在这个位置，事实上他在 偏移4byte的位置，上面的代码改成 <code>printf(&quot;%d\n&quot;, *(int *)(fp+4))</code> 就能读取到正确的结果(116) 这就是struct中的内存对齐。</p>
<p>要对struct 成员进行内存对齐的原因是 为了提升CPU对数据读取的效率，在大多数的架构中 CPU每次寻址 读取的是32bit的数据 也就是 4byte，如果变量在存储的时候没有内存对齐，CPU是以对齐的形式(32bit)读取数据的，这样就要读取两次 然后对数据重新组合才能得到值，这样提升了复杂度。</p>
<p>一般的程序中都是以 4 byte 内存对齐 可以通过宏定义来改变对齐值 <code>#pragma pack &lt;n&gt;</code>，内存对齐要达到的目的就是 在一个 4 byte的内存块中存储的下一个或多个变量，不能让变量跨两个 4 byte 内存块存储。对于变量 int long 都是 4byte倍数，short是 2byte 如果是这些变量存储是不需要考虑对齐的，怎样的存储都会对齐，但是出现的 char 类型占用 1byte内存就会 出现不对齐的情况了。内存对齐其实是解决<strong>如何存储char类型变量不使变量跨内存块存储</strong>的问题，并且在struct 中属性之间也是要按顺序进行存储的，不同的顺序会导致整个结构体需要占用的内存空间不同。</p>
<h4 id="4-2-联合体-union"><a href="#4-2-联合体-union" class="headerlink" title="4.2 联合体 union"></a>4.2 联合体 union</h4><p>联合体如何结构体也是多个变量的组合，不同点是他么占用的内存空间不同，结构体会给每一个属性分配内存空间，联合体只会分配一个最大属性存储需要的空间。所以联合体的内存空间中只能存储所有属性中的一个，各个属性可以定义不同类型，这些类型定义决定在读写内存的时候需要的内存空间偏移量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">union foo &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    union foo f;</span><br><span class="line">    f.a = 33;</span><br><span class="line">    f.b = 66;</span><br><span class="line">    // 最后的赋值会覆盖整个联合体申请的内存</span><br><span class="line">    printf(&quot;%d\t%d\n&quot;, f.a, f.b);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">66  66</span><br></pre></td></tr></table></figure>
<p>当一个小变量覆盖一个大变量的时候，其只会覆盖低地址需要覆盖的部分，读取也只会读取类型指定的内存长度的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union foo &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    union foo f;</span><br><span class="line">    f.b = 0x2310;</span><br><span class="line">    // a 是 char型 只会将值写入到地址前1byte</span><br><span class="line">    f.a = 0x40;</span><br><span class="line">    printf(&quot;%#x\n&quot;, f.b);</span><br><span class="line">    // 使用 属性b 填充一个 int 长度的值</span><br><span class="line">    f.b = 0x77889920;</span><br><span class="line">    // 读取属性 a 只会读取 1 byte的数据</span><br><span class="line">    printf(&quot;%#x\n&quot;, f.a);</span><br><span class="line">&#125;</span><br><span class="line">---------- result ----------</span><br><span class="line">0x2340</span><br><span class="line">0x20</span><br></pre></td></tr></table></figure>
<h4 id="整形提升"><a href="#整形提升" class="headerlink" title="整形提升"></a>整形提升</h4><p>看一个奇怪的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char c = 129;</span><br><span class="line">char * p = &amp;c;</span><br><span class="line">printf(&quot;%u\n&quot;, *p);</span><br><span class="line">---------- result ----------</span><br><span class="line">4294967169</span><br></pre></td></tr></table></figure>
<p>以上结果 已经超出了char所能表示的范围，有符号的 char 类型存储了一个值 129 这个值存储后实际表示的是负值 可以通过 <code>printf(&quot;%d&quot;, c);</code> 查看 其结果应该是 -127 ，这里我们将其以无符号的形式输出 就还应该得到 129 ，结果却得到一个更大的值，造成这种情况的原因是 <code>整形提升</code>。</p>
<p>我们的变量是存储在内存 char占用1byte，当需要计算的时候 CPU要将值读取到寄存器中的，寄存器一般都是 32位了也就是能存储 4byte的数据，当数据少于4byted的时候 CPU要做额外的工作处理这种输入不一致问题，CPU选择的是将变量的高位填充数据 既不影响计算 也不影响寄存器的存储，这个过程叫 <code>整形提升</code>。</p>
<p>其过程如下，如果是正数 高位填充 0 ，如果是负数 高位填充 1，将变量值补充对齐成 4 byte 的信号。正数高位补充 0 很明显不会造成影响，负数高位补充1的形式一时难以看出是否有影响，对于负数在内存中是以<code>补码</code>形式存储的，负数其实是正数在数轴上的对称位置上，负数的存储形式最高位一定是 1 ，当对其更高位补充1时 其表达的负数的值并没有变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">四位的 1001        对应表达的有符号值是 -1</span><br><span class="line">八位的 10000001    对应表达的有符号值是 -1</span><br></pre></td></tr></table></figure>

<p>熟悉负数补码的计算方式的话就很好理解了，可以看作 高位的1是表示正负数 剩下位是值。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/c/" rel="tag">c</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/26/php%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHashTable/"
                    data-tooltip="php内核源码分析之HashTable"
                    aria-label="上一篇: php内核源码分析之HashTable"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-free%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"
                    data-tooltip="malloc源码分析-free内存释放"
                    aria-label="下一篇: malloc源码分析-free内存释放"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 fantiq. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/26/php%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHashTable/"
                    data-tooltip="php内核源码分析之HashTable"
                    aria-label="上一篇: php内核源码分析之HashTable"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-free%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"
                    data-tooltip="malloc源码分析-free内存释放"
                    aria-label="下一篇: malloc源码分析-free内存释放"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://fantiq.github.io/2019/05/26/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"
                        aria-label="分享到 Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">fantiq</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                China HangZhou
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-ffzlst6ssezilzbbgybxfwuegfobjsmomzthas0h8hymsrrzox2o6dre4owp.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
